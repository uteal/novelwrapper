/*! NovelWrapper v0.4.3 | (c) 2025 uteal | MIT License *//**
 * Makes a new novel from the scenes given. Returns a handle with a set of useful methods.
 * @param {string} novelTag A novel-specific name used when saving or restoring a game state.
 * @param {(function|function[])} factories A function or array of functions that return dictionaries of novel scenes.
 * @param {object} params Initial params.
 * @param {object} params.$ Initial game state. Should be JSON-serializable. Empty object by default.
 * @param {object} params.ext A helper object for passing custom functions or data to scenes.
 * @param {(object|object[])} params.callbacks Callbacks for standard events in form of object or array of objects.
 * @param {boolean} params.devMode Allows the engine to output logs. Essential during development.
 * @param {number} params.stepTime The time it takes to print each symbol in milliseconds. Instant if zero.
 * @param {string} params.cssPrefix Engine will use this when searching for CSS styles. Default is "novel".
 * @param {string} params.watchedAttr The engine will track elements with this attribute, listen to their events and apply CSS classes.
 * @param {string} params.imagesPath Path to the folder with portraits of the novel's characters.
 * @param {string} params.imagesType File extension of the novel's character portraits. Default is "png".
 * @param {(string|null)} params.firstScene Entry point of the novel, defaults to "start". Set to null to prevent the game from starting automatically.
 * @param {string} params.restoreFromSlot The game tries to load from the specified slot, "autosave" by default.
 * @param {boolean} params.startOver Should the game ignore the save data and start over?
 * @param {boolean} params.noReadWrite Do not read or write the game state. Default is false.
 * @param {boolean} params.noKeyboard Ignore keyboard controls. Default is false.
 * @param {boolean} params.useLocationHash If true, the game will store its state as the hash property of the window location object.
 * @param {(string|HTMLElement)} params.appendTo Where the novel element should be placed. Defaults to document.body.
 * @param {object} params.implementations An object with functions that will override certain engine methods. They run in the context of this object.
 * @param {object} params.delays Engine animation delays, for deep customization. See the engine file for a list of them.
 * @param {('left'|'right')} params.defaultAlign Starting alignment of each character. Default is "right".
 * @param {RegExp} params.multiLangSplitRegex Delimiter of multilingual strings. /\s+>>\s+/ by default.
 * @param {number} params.language Which part of the split multilingual string should be shown. Default: -1 (i.e. no translation).
 * @preserve
 */export default(J,O,{$:ke={},ext:Ne={},callbacks:B=[],devMode:ie=!0,stepTime:Ie=1e3/60,cssPrefix:i="novel",watchedAttr:C=void 0,imagesPath:de="./images/",imagesType:Pe="png",firstScene:je="start",restoreFromSlot:Fe="autosave",startOver:We=!1,noReadWrite:re=!1,noKeyboard:ue=!1,useLocationHash:Y=!1,appendTo:z=document.body,implementations:Be={},delays:Ge={},defaultAlign:pe="right",multiLangSplitRegex:qe=/\s+>>\s+/,language:oe=-1}={})=>{if(!O||Array.isArray(O)&&!O.length)throw new Error("You should provide at least one scene factory function.");const me="Sasuke",De=de+(de.endsWith("/")?"":"/"),He=Pe.toLowerCase();let V=!1,ge,Z=!1;const Q="AbortSignal",X={},S=()=>{if(Z)throw Q},p={},N={},we={},G=[],q={};let D,g,m,ye,_,ee,te,H=0,I=!1,se=!1,P=!1,M=!1,ae=!1,K=!1,U,L,T,d,le,w,$,A;const x={CHARACTER_SHOW:350,CHARACTER_HIDE:350,CHARACTER_MOOD_CHANGE:100,BEFORE_SELECT_ACTIVE:350,AFTER_OPTION_CLICK:250,BEFORE_FIRST_PRINT:500,BEFORE_SKIP_PRINTING:200,BEFORE_IDLE_PROCEED:500},f={onGameStart:null,onShow:null,onHide:null,onBeforeType:null,onStop:null,onSceneEnter:null,onSceneLeave:null,onWatcherCreate:null,onWatcherRemove:null,onEventEnter:null,onEventLeave:null,onShowOptions:null,onOptionClick:null,onStateChange:null,onGameEnd:null},y={getCharacterPortraitPath(t,e){return`${De}${t}/${e}.${He}`},createKey(t,e){return`${t}(${e})`},writeState(t,e){if(Y){let s={};try{s=JSON.parse(decodeURIComponent(window.location.hash).slice(1))}catch{}s[t]=e,window.history.pushState(void 0,void 0,"#"+JSON.stringify(s))}else localStorage.setItem(t,JSON.stringify(e))},readState(t){if(h("\u21BB",t),Y){let e={};try{e=JSON.parse(decodeURIComponent(window.location.hash).slice(1))}catch{}return e[t]}else{let e;try{e=JSON.parse(localStorage.getItem(t))}catch{}return e}},clearSavedState(t){if(h("\u{1F5D1}\uFE0F",t),Y){let e={};try{e=JSON.parse(decodeURIComponent(window.location.hash).slice(1))}catch{}delete e[t],window.history.replaceState(void 0,void 0,"#"+JSON.stringify(e))}else localStorage.removeItem(t)},onUserNavigates(){Y&&window.history.go(0)}},be=new Proxy(p,{set(t,e,s){return t.$[e]=s,f.onStateChange?.(e,s),!0},get(t,e){return t.$[e]}}),ve=new Proxy(we,{get(t,e){return Object.hasOwn(t,e)||(t[e]=new ce(e)),t[e].proxy}}),j=(t=!1)=>{if(!Z&&(P||t)&&_){P=!1;const e=_;_=null,e()}},Me=async({target:t})=>{if(!Z&&P&&ee&&t?.classList.contains(i+"-select-option")){P=!1,f.onOptionClick?.();const e=t.getAttribute("select-option-value")??[...A.querySelectorAll("."+i+"-select-option")].findIndex(n=>t===n);A.classList.add(i+"-select-hidden");const s=ee;ee=null,h("\u{1F449}",t.innerText),await v(x.AFTER_OPTION_CLICK),se=!1,s(e)}};class Ke{constructor(){Object.assign(x,Ge),U=b(i+"-container",i+"-layer"),L=b(i+"-dialogs",i+"-layer"),T=b(i+"-choices",i+"-layer"),d=b(i+"-textbox",i+"-textbox-hidden"),le=b(i+"-message"),w=xe(i+"-message-rendered"),$=xe(i+"-message-placeholder"),A=b(i+"-select",i+"-select-hidden"),U.append(L,T),le.append(w,$),d.append(le),L.append(d),T.append(A),L.addEventListener("click",()=>j()),A.addEventListener("click",s=>Me(s)),Array.isArray(B)||(B=[B]),C&&B.push(ze()),this.setCallbacks(B);for(const[s,n]of Object.entries(Be))Object.hasOwn(y,s)?y[s]=n:console.error(`Unknown name for implementation given: "${s}".`);this.getScenes(),typeof z=="string"&&(z=document.querySelector(z)),z.append(U);const e=!We&&this.loadState(Fe);e&&e.version===me?Object.assign(p,e):(h("\u{1F3AC}",J),Object.assign(p,this.createNewState()),Object.assign(p.$,ke)),h("\u{1F4E6}",structuredClone(p)),F(()=>{V=!0,p.scene&&this.runScene(p.scene,!1),f.onGameStart?.(X),ge?.(X)})}setCallbacks(e){const s=Object.fromEntries(Object.keys(f).map(n=>[n,[]]));for(const n of e)for(const[r,o]of Object.entries(n)){if(!Object.hasOwn(s,r)){console.error("Unknown callback:",r);continue}s[r].push(o)}for(const[n,r]of Object.entries(s))r.length>0&&(f[n]=r.length===1?r[0]:function(...o){r.forEach(a=>a.apply(this,o))})}getScenes(){Array.isArray(O)||(O=[O]);for(const e of O)Object.entries(e({$:be,watch:Je,select:Ye,call:Ze,print:Qe,clear:Xe,sleep:v,save:this.saveState,log:h,ext:Ne})).forEach(([s,n])=>{Object.hasOwn(N,s)?console.error("Scene redeclaration:",s):N[s]=new Ue(s,n)})}saveState(e="autosave"){if(S(),re)return;const s=y.createKey?.(J,e);return y.writeState?.(s,structuredClone(p))}loadState(e){if(S(),re)return;const s=y.createKey?.(J,e);return y.readState?.(s)}clearSaveSlot(e){if(S(),re)return;const s=y.createKey?.(J,e);return y.clearSavedState?.(s)}createNewState(){return{$:{},scene:je,characters:{},version:me}}async runScene(e,s=!0){if(S(),h("\u26F0\uFE0F",e),e?.[0]==="~"?e=e.slice(1):m?.hide(),g&&g.end(),!Object.hasOwn(N,e)){console.error("Trying to run unknown scene:",e);return}g=N[e],p.scene=e,s&&this.saveState("autosave"),f.onSceneEnter?.(e,!0);let n;try{n=await g.run()}catch(r){if(r===Q){h("\u270B","The game was manually interrupted."),h("\u{1FA82}","Emergency exiting.");return}else throw r}f.onSceneLeave?.(e,!0),typeof n=="string"?setTimeout(()=>this.runScene(n)):n!==void 0&&(h("\u{1F3C1}","Game ended."),f.onGameEnd?.(n))}async notify(e,...s){if(S(),h("\u26A1",e),!g){console.error(`Event "${e}" occured while no scene is active`);return}if(!M){console.error(`Event "${e}" occured while the script flow was not ended.`);return}const n=g.watchers.find(r=>r.event===e);if(!n){h("\u{1F965}","No such watcher.");return}if(!n.cb){h("\u{1F34B}","Callback not set.");return}if(n){M=!1,f.onEventEnter?.(e,...s);let r;try{r=await n.cb(...s)}catch(o){if(o===Q){h("\u270B","The game was manually interrupted."),h("\u{1FA82}","Emergency exiting.");return}else throw o}f.onEventLeave?.(e,r),typeof r=="string"?ye(r):(r===!1&&g.removeWatcher(e),m?.hide(),T.style.pointerEvents="none",L.style.pointerEvents="none",M=!0,h("\u26F0\uFE0F",g.id,"\u21A9"))}}}class Ue{watchers=[];constructor(e,s){this.id=e,this.cb=s}async run(){let e=await this.cb(ve);return e===void 0&&(M=!0,m?.hide(),T.style.pointerEvents="none",L.style.pointerEvents="none",U.style.pointerEvents="none",this.watchers.length?e=await new Promise(s=>{ye=s}):h("\u{1F6A7}","The game has stalled.")),e}removeWatcher(e){const s=this.watchers.findIndex(n=>n.event===e);s!==-1&&(this.watchers.splice(s,1),f.onWatcherRemove?.(e),h("\u{1F9F9}",e))}end(){this.watchers.forEach(({event:e})=>{f.onWatcherRemove?.(e)}),this.watchers=[]}}function Je(t,e){if(S(),g.watchers.some(n=>n.event===t)){console.error(`Multiple watchers of the same event (${t}) not allowed at scene (${g.id})`);return}h("\u{1F4CC}",t),g.watchers.push({event:t,cb:e}),f.onWatcherCreate?.(t);const s=g.id;return{then:()=>{console.error(`There is no point in "await" before "watch" (scene: "${s}", event: "${t}").`)}}}class ce{constructor(e){h("\u{1F98A}",e),this.id=e,this.label="",this.align=pe,this.flipped=!1,this.visible=!1,this.timeout,this.mood="normal",this.queue=[];let s="normal";const n=(...r)=>{if(ie){for(const{id:o,queue:a}of Object.values(we))if(a.length){console.error(`Unexpected state. Check the "await" before these words of ${o}:`,[...a]);return}}return this.proxy__(...r)};if(Object.assign(n,{$toLeft:()=>(this.setAlign("left"),p.characters[e].align="left",this.proxy_),$toRight:()=>(this.setAlign("right"),p.characters[e].align="right",this.proxy_),$setLabel:r=>(this.setLabel(r),p.characters[e].label=r,this.proxy_),$flipImage:()=>(this.setFlip(!this.flipped),p.characters[e].flipped=this.flipped,this.proxy_),then:()=>{console.error(`Seemingly useless "await" before ${this.id}'s handle. This error may be caused by:
1. Erroneous usage of "await" with syncronous methods like "$toLeft", "$toRight", "$setLabel".
2. Using quotes or double quotes instead of backticks in parenthesis-less notation.
3. Using a comma or semicolon before the first argument in parenthesis-less notation.`)}}),this.proxy=new Proxy(n,{get:(r,o)=>Object.hasOwn(r,o)?r[o]:(s=o,this.proxy__)}),this.proxy_=new Proxy(n,{apply:()=>{console.error("Direct function call in a method chain. Chaining of methods and function calls is prohibited.")}}),this.proxy__=new Proxy(n,{get:(r,o)=>{if(o==="then")return async(a,l)=>{const u=this.queue;this.queue=[],await this.say(s,...u).catch(l),s="normal",a()};console.error(`Once the call chain has started, property getting is not allowed. Requested property: "${o}".`)},apply:(r,o,a)=>(Array.isArray(a[0])&&Array.isArray(a[0].raw)&&(a=[_e(...a)]),this.queue.push(...a),this.proxy__)}),this.$el=b(i+"-character",i+"-character-id-"+e,i+"-character-align-"+this.align,i+"-character-inactive"),this.$portraits=b(i+"-character-portraits"),this.$label=b(i+"-label",i+"-label-id-"+e,i+"-label-hidden"),this.$el.append(this.$portraits,this.$label),Object.hasOwn(p.characters,e)){const r=p.characters[e];this.setLabel(r.label),this.setAlign(r.align),this.setFlip(r.flipped),h("\u21BB",r)}else p.characters[e]={}}setLabel(e=""){this.$label.innerText=e,this.label=e,e?this.visible&&this.$label.classList.remove(i+"-label-hidden"):this.$label.classList.add(i+"-label-hidden")}setAlign(e=pe){e!==this.align&&(this.$el.classList.remove(i+"-character-align-"+this.align),this.$el.classList.add(i+"-character-align-"+e),this.align=e,this.visible&&this.updateTextboxAlign())}setFlip(e=!1){this.flipped=e,e?this.$el.classList.add(i+"-character-flipped"):this.$el.classList.remove(i+"-character-flipped")}setMood(e){return e!==this.mood?(this.$el.classList.remove(i+"-character-mood-"+this.mood),this.$el.classList.add(i+"-character-mood-"+e),this.mood=e,!0):!1}async show(e=this.mood){const s=this.setMood(e),n=!!m&&m===this,r=!!m&&m.align===this.align;let o=this.$portraits.querySelector("."+i+"-portrait-mood-"+e);o?o.classList.contains(i+"-portrait-hidden")&&this.$portraits.append(o):(o=b(i+"-portrait",i+"-portrait-mood-"+e,i+"-portrait-hidden"),this.$portraits.append(o),await new Promise(a=>{let l=y.getCharacterPortraitPath(this.id,e);ie&&(l+="?"+Math.random());const u=new Image;u.src=l,u.onload=()=>{o.style.backgroundImage=`url('${l}')`,a()},u.onerror=()=>{a()}})),n||(r?await m?.hide():m?.hide()),o.classList.contains(i+"-portrait-hidden")&&F(()=>{o.classList.remove(i+"-portrait-hidden")}),this.visible?await F(async()=>{await v(s?x.CHARACTER_MOOD_CHANGE:0);for(let a=0;a<this.$portraits.children.length-1;a++)this.$portraits.children[a].classList.add(i+"-portrait-hidden");this.updateTextboxAlign()}):(this.visible=!0,m=this,w.replaceChildren(),$.innerText="",L.append(this.$el),clearTimeout(this.timeout),f.onShow?.(this.id),await F(()=>{this.$el.classList.remove(i+"-character-inactive"),d.classList.remove(i+"-textbox-hidden");for(let a=d.classList.length-1;a>=0;a--){const l=d.classList[a];l.startsWith(i+"-textbox-of-")&&d.classList.remove(l)}d.classList.add(i+"-textbox-of-"+this.id),this.updateTextboxAlign()}),this.label?this.$label.classList.remove(i+"-label-hidden"):this.$label.classList.add(i+"-label-hidden"),await v(x.CHARACTER_SHOW))}async hide(){if(!this)await F(()=>{I||d.classList.add(i+"-textbox-hidden")});else if(this.visible){this.visible=!1,m=void 0,this.$el.classList.remove(i+"-character-mood-"+this.mood),this.$el.classList.add(i+"-character-inactive"),this.$label.classList.add(i+"-label-hidden");for(const e of this.$portraits.children)e.classList.add(i+"-portrait-hidden");await F(()=>{I||d.classList.add(i+"-textbox-hidden")}),f.onHide?.(this.id),this.timeout=setTimeout(()=>this.$el.remove(),5e3),await v(x.CHARACTER_HIDE)}}updateTextboxAlign(){this.align==="left"?(d.classList.remove(i+"-textbox-right"),d.classList.add(i+"-textbox-left")):(d.classList.remove(i+"-textbox-left"),d.classList.add(i+"-textbox-right"))}async say(e,...s){if(S(),I||se){console.error("Message from "+(this?.id??"[print]")+' was ignored because the previous task was not finished. Check if you placed "await"s correctly.'),console.error("Message:",s);return}I=!0,L.style.pointerEvents="all",T.style.pointerEvents="none";const n=[];for(const r of s)Array.isArray(r)?n.push(...r):n.push(r);if(this)d.classList.remove(i+"-textbox-printed"),await this.show(e);else{const r=d.classList.contains(i+"-textbox-hidden"),o=r||!!m;m?.hide(),w.replaceChildren(),$.innerText="",d.classList.remove(i+"-textbox-left"),d.classList.remove(i+"-textbox-right"),d.classList.add(i+"-textbox-printed"),r&&d.classList.remove(i+"-textbox-hidden"),o&&await v(x.BEFORE_FIRST_PRINT)}for(let r=0;r<n.length;r++){if(typeof n[r]!="string")continue;let o=!1,a=0,l=Ie,u=[];typeof n[r+1]=="number"&&(o=!0,a=n[r+1]);let[c,E]=Oe(Se(n[r]));if(c[0]==="["){const k=c.indexOf("]");if(k!==-1){const ne=c.indexOf("::");(ne===-1||ne>k)&&(u=c.slice(1,k).split(""),E=E.slice(k+1),c=c.slice(k+1))}}u.includes("!")&&(l=0),u.includes("~")&&(l=l*2),await et(...Le(c,E),l,u.includes("+")),u.includes("+")&&G.pop(),G.push({id:this?.id??"[print]",label:this?.label??"[print]",text:w.innerText}),G.length>100&&G.shift(),o?w.classList.add(i+"-message-rendered-writing"):w.classList.add(i+"-message-rendered-stopped");let R;const W=new Promise((k,ne)=>{R=k,te=ne}),Re=()=>(P=!0,f.onStop?.(),W);_=()=>{w.classList.remove(i+"-message-rendered-writing"),w.classList.remove(i+"-message-rendered-stopped"),R()},K&&await v(x.BEFORE_SKIP_PRINTING),K?j(!0):o?(await v(a),j(!0)):q[" "]?(await v(x.BEFORE_IDLE_PROCEED),q[" "]?j(!0):await Re()):await Re()}I=!1}}async function Ye(...t){if(S(),h("\u{1F4CB}",t),I||se){console.error('Cannot show selectable options because the previous task was not finished. Check if you placed "await"s correctly.'),console.error("Options:",t);return}if(t=t.filter(e=>typeof e=="string"||e instanceof Object),!!t.length)return se=!0,P=!0,T.style.pointerEvents="all",A.replaceChildren(...t.map(e=>{const s=b(i+"-select-option");if(typeof e!="string"){const a=Object.entries(e)[0];s.setAttribute("select-option-value",a[0]),e=a[1]}const[n,r]=Le(...Oe(Se(e))),o=fe(n);for(let a=0;a<o.length;a++)f.onBeforeType?.(n[a],o[a],r[a],0,!0);return s.replaceChildren(...o),s})),A.classList.remove(i+"-select-hidden"),f.onShowOptions?.(),await v(x.BEFORE_SELECT_ACTIVE),new Promise((e,s)=>{te=s,ee=e})}const Ee=(t,...e)=>{const s=document.createElement(t);return s.classList.add(...e),s},b=Ee.bind(null,"div"),xe=Ee.bind(null,"span");function F(t){return new Promise(e=>{requestAnimationFrame(()=>{requestAnimationFrame(async()=>{await t(),e()})})})}function ze(){const t=[];return{onWatcherCreate(e){document.querySelectorAll(`[${C}="${e}"]`).forEach(s=>{s.classList.add(i+"-watched"),s.addEventListener("click",he),t.push(s)})},onWatcherRemove(e){for(let s=t.length-1;s>=0;s--){const n=t[s];n.getAttribute(C)===e&&(n.classList.remove(i+"-watched"),n.removeEventListener("click",he),t.splice(s,1))}},onEventEnter(e){t.forEach(s=>{s.getAttribute(C)===e?s.classList.add(i+"-watched-clicked"):s.classList.add(i+"-watched-clicked-other")})},onEventLeave(){t.forEach(e=>{e.classList.remove(i+"-watched-clicked"),e.classList.remove(i+"-watched-clicked-other")})}}}function he(){D.notify(this.getAttribute(C))}function Ve(){document.removeEventListener("keydown",Ce),document.removeEventListener("keyup",Te),window.removeEventListener("popstate",Ae),C&&document.querySelectorAll(`[${C}]`).forEach(t=>{t.removeEventListener("click",he),t.classList.remove(i+"-watched"),t.classList.remove(i+"-watched-clicked"),t.classList.remove(i+"-watched-clicked-other")})}function Ze(t,...e){if(!Object.hasOwn(N,t)){console.error("Trying to call unknown scene:",t);return}if(H>99){console.error(`Scene "${t}" cannot be called: stack size limit reached (${H}).`);return}return H+=1,h("\u{1F4AC}",t),(async()=>{f.onSceneEnter?.(t,!1);const s=await N[t].cb(ve,...e);return f.onSceneLeave?.(t,!1),H-=1,H||h("\u26F0\uFE0F",g?.id,"\u21A9"),s})()}function Qe(...t){return ce.prototype.say.call(null,null,...t)}function Xe(){return m?m.hide():ce.prototype.hide.call(null)}function v(t){return new Promise((e,s)=>{te=s,setTimeout(e,t)})}function Se(t){if(oe!==-1&&typeof t=="string"){const e=t.split(qe);return oe<e.length?e[oe]:e[0]}return t}function _e(t,...e){let s="";for(let n=0;n<t.length;n++)s+=t[n],n<t.length-1&&(s+=`${e[n]}`);return s}function et(t,e,s,n,r){return r||(w.replaceChildren(),$.innerText=t),new Promise(o=>{const a=l=>{if(K||n===0){const u=fe(t.slice(l));for(let c=0;c<u.length;c++)f.onBeforeType?.(t[l+c],u[c],e[l+c],0,!1);w.append(...u),r||($.innerText=""),o()}else if(l<t.length){const u=ae?n/2:n;setTimeout(()=>{const c=fe(t[l])[0],E=f.onBeforeType?.(t[l],c,e[l],u,!1);if(!E)w.append(c),r||($.innerText=t.slice(l+1)),a(l+1);else{let R=0,W=0;if(typeof E=="number")R=E/2,W=E/2;else if(Array.isArray(E))R=E[0]??R,W=E[1]??W;else throw new Error("onBeforeType callback must return undefined, number or array");setTimeout(()=>{w.append(c),r||($.innerText=t.slice(l+1)),setTimeout(()=>a(l+1),W)},R)}},u+s[l])}else o()};a(0)})}function fe(t){const e=[];for(const s of t){const n=document.createElement("span");n.style.pointerEvents="none",n.innerText=s,e.push(n)}return e}function tt(t,e=0){if(!t.slice(e).includes("::"))return!1;const s=/[!?.,;:\s"()\]]/;let n,r;for(let o=e;o<t.length;o++)if(t[o]==="[")n=o;else if(t[o]===":"&&t[o+1]===":"){for(let a=o+2;a<=t.length;a++)if(a===t.length||t[a]==="]"||n===void 0&&s.test(t[a])){const l=n??r;return[l!==void 0?l+1:e,o+2,a]}}else n===void 0&&s.test(t[o])&&(r=o);return!1}function st(t){const e=[];let s=0;for(;;){const n=tt(t,s);if(n)e.push(n),s=n[2]+1;else return e}}function Le(t,e=[]){const s=st(t);if(!s.length)return[t,[],e];const n=t.split(""),r=Array(t.length).fill(void 0);for(const[o,a,l]of s){const u=t.slice(o,a-2);for(let c=o;c<a;c++)n[c]=!1,r[c]=!1,$e(e,c);for(let c=a;c<l;c++)r[c]=u}for(let o=0;o<n.length;o++)(n[o]==="["||n[o]==="]")&&(n[o]=!1,r[o]=!1,$e(e,o));return[n.filter(o=>o!==!1).join(""),r.filter(o=>o!==!1),e.filter(o=>o!==!1)]}function $e(t,e){for(let s=e;s<t.length;s++)if(t[s]===0){t[s]=!1;return}}function Oe(t){const e="0123456789",s=t.split(""),n=Array(t.length).fill(0);for(let r=0;r<s.length;r++)if(s[r]==="["){let o="",a;for(a=r+1;a<s.length&&s[a]!=="]";a++)if(e.includes(s[a]))o+=s[a];else{o="";break}if(o){n[a+1]=+o;for(let l=r;l<=a;l++)s[l]=!1,n[l]=!1}r=a}return[s.filter(r=>r!==!1).join(""),n.filter(r=>r!==!1)]}function h(...t){ie&&console.log(...t.map(e=>e===be?p.$:e))}const Ce=({key:t})=>{if(!ue&&!q[t])switch(q[t]=!0,t){case" ":ae=!0,j();break;case"Control":j(),K=!0;break}},Te=({key:t})=>{if(!ue)switch(delete q[t],t){case" ":ae=!1;break;case"Control":K=!1;break}},Ae=t=>{y.onUserNavigates?.()};return document.addEventListener("keydown",Ce),document.addEventListener("keyup",Te),window.addEventListener("popstate",Ae),D=new Ke,Object.assign(X,{event:(t,...e)=>{if(!V){console.error('Game is not ready. Use "await createNovel(...).promise" for proper timing.');return}D.notify(t,...e)},runScene:t=>{if(!V){console.error('Game is not ready. Use "await createNovel(...).promise" for proper timing.');return}M?console.error(`Manual scene run failed: script flow not ended. (Scene: "${t}")`):D.runScene(t)},getHistory:()=>G,clearSaveSlot:(t="autosave")=>D.clearSaveSlot(t),remove:()=>{if(!V){console.error('Game is not ready. Use "await createNovel(...).promise" for proper timing.');return}Z=!0,Ve(),U.remove();for(const t of Object.keys(f))f[t]=null;for(const t of Object.keys(y))y[t]=null;te?.(Q)},sleep:v,log:h,promise:new Promise(t=>{ge=t})}),X};
