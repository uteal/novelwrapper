/*! NovelWrapper v0.4.0 | (c) 2025 uteal | MIT License *//**
 * Makes a new novel from the scenes given. Returns a handle with a set of useful methods.
 * @param {string} novelTag A novel-specific name used when saving or restoring a game state.
 * @param {(function|function[])} factories A function or array of functions that return dictionaries of novel scenes.
 * @param {object} params Initial params.
 * @param {object} params.$ Initial game state. Should be JSON-serializable. Empty object by default.
 * @param {object} params.ext A helper object for passing custom functions or data to scenes.
 * @param {(object|object[])} params.callbacks Callbacks for standard events in form of object or array of objects.
 * @param {boolean} params.devMode Allows the engine to output logs. Essential during development.
 * @param {number} params.stepTime The time it takes to print each symbol in milliseconds. Instant if zero.
 * @param {string} params.cssPrefix Engine will use this when searching for CSS styles. Default is "novel".
 * @param {string} params.watchedAttr The engine will track elements with this attribute, listen to their events and apply CSS classes.
 * @param {string} params.imagesPath Path to the folder with portraits of the novel's characters.
 * @param {string} params.imagesType File extension of the novel's character portraits. Default is "png".
 * @param {string} params.firstScene Entry point of the novel, defaults to "start".
 * @param {string} params.restoreFromSlot The game tries to load from the specified slot, "autosave" by default. Nullify to start over.
 * @param {boolean} params.useLocationHash If true, the game will store its state as the hash property of the window location object.
 * @param {(string|HTMLElement)} params.appendTo Where the novel element should be placed. Defaults to document.body.
 * @param {object} params.implementations An object with functions that will override certain engine methods. They run in the context of this object.
 * @param {object} params.delays Engine animation delays, for deep customization. See the engine file for a list of them.
 * @param {('left'|'right')} params.defaultAlign Starting alignment of each character. Default is "right".
 * @param {RegExp} params.multiLangSplitRegex Delimiter of multilingual strings. /\s+>>\s+/ by default.
 * @param {number} params.language Which part of the split multilingual string should be shown. Default: -1 (i.e. no translation).
 * @preserve
 */export default(D,L,{$:xe={},ext:Se={},callbacks:P=[],devMode:Z=!0,stepTime:Le=1e3/60,cssPrefix:i="novel",watchedAttr:$=void 0,imagesPath:ae="./images/",imagesType:$e="png",firstScene:Oe="start",restoreFromSlot:oe="autosave",useLocationHash:K=!1,appendTo:B=document.body,implementations:Ce={},delays:Te={},defaultAlign:le="right",multiLangSplitRegex:Ae=/\s+>>\s+/,language:_=-1}={})=>{if(!L||Array.isArray(L)&&!L.length)throw new Error("You should provide at least one scene factory function.");const ce="Sasuke",Re=ae+(ae.endsWith("/")?"":"/"),ke=$e.toLowerCase();let M=!1;const G="AbortSignal",ee={},x=()=>{if(M)throw G},u={},A={},he={},j=[],F={};let U,m,p,de,J,z,V,W=0,R=!1,Y=!1,k=!1,Q=!1,te=!1,q=!1,H,S,O,f,se,g,C,T;const E={CHARACTER_SHOW:350,CHARACTER_HIDE:350,CHARACTER_MOOD_CHANGE:100,BEFORE_SELECT_ACTIVE:350,AFTER_OPTION_CLICK:250,BEFORE_FIRST_PRINT:500,BEFORE_SKIP_PRINTING:200,BEFORE_IDLE_PROCEED:500},d={onGameStart:null,onShow:null,onHide:null,onType:null,onStop:null,onSceneEnter:null,onSceneLeave:null,onWatcherCreate:null,onWatcherRemove:null,onEventEnter:null,onEventLeave:null,onShowOptions:null,onOptionClick:null,onStateChange:null,onGameEnd:null},w={getCharacterPortraitPath(t,e){return`${Re}${t}/${e}.${ke}`},createKey(t,e){return`${t}(${e})`},writeState(t,e){if(K){let s={};try{s=JSON.parse(decodeURIComponent(window.location.hash).slice(1))}catch{}s[t]=e,window.history.pushState(void 0,void 0,"#"+JSON.stringify(s))}else localStorage.setItem(t,JSON.stringify(e))},readState(t){if(h("\u21BB",t),K){let e={};try{e=JSON.parse(decodeURIComponent(window.location.hash).slice(1))}catch{}return e[t]}else{let e;try{e=JSON.parse(localStorage.getItem(t))}catch{}return e}},clearSavedState(t){if(h("\u{1F5D1}\uFE0F",t),K){let e={};try{e=JSON.parse(decodeURIComponent(window.location.hash).slice(1))}catch{}delete e[t],window.history.replaceState(void 0,void 0,"#"+JSON.stringify(e))}else localStorage.removeItem(t)},onUserNavigates(){K&&window.history.go(0)}},fe=new Proxy(u,{set(t,e,s){return t.$[e]=s,d.onStateChange?.(e,s),!0},get(t,e){return t.$[e]}}),ue=new Proxy(he,{get(t,e){return Object.hasOwn(t,e)||(t[e]=new ne(e)),t[e].proxy}}),N=(t=!1)=>{if(!M&&(k||t)&&J){k=!1;const e=J;J=null,e()}},Ne=async({target:t})=>{if(!M&&k&&z&&t?.classList.contains(i+"-select-option")){k=!1,d.onOptionClick?.();const e=t.getAttribute("select-option-value")??[...T.querySelectorAll("."+i+"-select-option")].findIndex(n=>t===n);T.classList.add(i+"-select-hidden");const s=z;z=null,h("\u{1F449}",t.innerText),await v(E.AFTER_OPTION_CLICK),Y=!1,s(e)}};class Ie{constructor(){Object.assign(E,Te),H=b(i+"-container",i+"-layer"),S=b(i+"-dialogs",i+"-layer"),O=b(i+"-choices",i+"-layer"),f=b(i+"-textbox",i+"-textbox-hidden"),se=b(i+"-message"),g=me(i+"-message-rendered"),C=me(i+"-message-placeholder"),T=b(i+"-select",i+"-select-hidden"),H.append(S,O),se.append(g,C),f.append(se),S.append(f),O.append(T),S.addEventListener("click",()=>N()),T.addEventListener("click",s=>Ne(s)),Array.isArray(P)||(P=[P]),$&&P.push(We()),this.setCallbacks(P);for(const[s,n]of Object.entries(Ce))Object.hasOwn(w,s)?w[s]=n:console.error(`Unknown name for implementation given: "${s}".`);this.getScenes(),typeof B=="string"&&(B=document.querySelector(B)),B.append(H);const e=!!oe&&this.loadState(oe);e&&e.version===ce?Object.assign(u,e):(h("\u{1F3AC}",D),Object.assign(u,this.createNewState()),Object.assign(u.$,xe)),h("\u{1F4E6}",structuredClone(u)),I(()=>{this.runScene(u.scene,!1),d.onGameStart?.(ee)})}setCallbacks(e){const s=Object.fromEntries(Object.keys(d).map(n=>[n,[]]));for(const n of e)for(const[r,a]of Object.entries(n)){if(!Object.hasOwn(s,r)){console.error("Unknown callback:",r);continue}s[r].push(a)}for(const[n,r]of Object.entries(s))r.length>0&&(d[n]=r.length===1?r[0]:function(...a){r.forEach(o=>o.apply(this,a))})}getScenes(){Array.isArray(L)||(L=[L]);for(const e of L)Object.entries(e({$:fe,watch:je,select:Fe,call:He,print:De,clear:Ke,sleep:v,save:this.saveState,log:h,ext:Se})).forEach(([s,n])=>{Object.hasOwn(A,s)?console.error("Scene redeclaration:",s):A[s]=new Pe(s,n)})}saveState(e="autosave"){x();const s=w.createKey?.(D,e);w.writeState?.(s,structuredClone(u))}loadState(e){x();const s=w.createKey?.(D,e);return w.readState?.(s)}clearSaveSlot(e){x();const s=w.createKey?.(D,e);w.clearSavedState?.(s)}createNewState(){return{$:{},scene:Oe,characters:{},version:ce}}async runScene(e,s=!0){if(x(),h("\u26F0\uFE0F",e),e?.[0]==="~"?e=e.slice(1):p?.hide(),m&&m.end(),!Object.hasOwn(A,e)){console.error("Trying to run unknown scene:",e);return}m=A[e],u.scene=e,s&&this.saveState("autosave"),d.onSceneEnter?.(e,!0);let n;try{n=await m.run()}catch(r){if(r===G){h("\u270B","The game was manually interrupted."),h("\u{1FA82}","Emergency exiting.");return}else throw r}d.onSceneLeave?.(e,!0),typeof n=="string"?setTimeout(()=>this.runScene(n)):n!==void 0&&(h("\u{1F3C1}","Game ended."),d.onGameEnd?.(n))}async notify(e,...s){if(x(),h("\u26A1",e),!m){console.error(`Event "${e}" occured while no scene is active`);return}if(!Q){console.error(`Event "${e}" occured while the script flow was not ended.`);return}const n=m.watchers.find(r=>r.event===e);if(!n){h("\u{1F965}","No such watcher.");return}if(!n.cb){h("\u{1F34B}","Callback not set.");return}if(n){Q=!1,d.onEventEnter?.(e,...s);let r;try{r=await n.cb(...s)}catch(a){if(a===G){h("\u270B","The game was manually interrupted."),h("\u{1FA82}","Emergency exiting.");return}else throw a}d.onEventLeave?.(e,r),typeof r=="string"?de(r):(r===!1&&m.removeWatcher(e),p?.hide(),O.style.pointerEvents="none",S.style.pointerEvents="none",Q=!0,h("\u26F0\uFE0F",m.id,"\u21A9"))}}}class Pe{watchers=[];constructor(e,s){this.id=e,this.cb=s}async run(){let e=await this.cb(ue);return e===void 0&&(Q=!0,p?.hide(),O.style.pointerEvents="none",S.style.pointerEvents="none",H.style.pointerEvents="none",this.watchers.length?e=await new Promise(s=>{de=s}):h("\u{1F6A7}","The game has stalled.")),e}removeWatcher(e){const s=this.watchers.findIndex(n=>n.event===e);s!==-1&&(this.watchers.splice(s,1),d.onWatcherRemove?.(e),h("\u{1F9F9}",e))}end(){this.watchers.forEach(({event:e})=>{d.onWatcherRemove?.(e)}),this.watchers=[]}}function je(t,e){if(x(),m.watchers.some(n=>n.event===t)){console.error(`Multiple watchers of the same event (${t}) not allowed at scene (${m.id})`);return}h("\u{1F4CC}",t),m.watchers.push({event:t,cb:e}),d.onWatcherCreate?.(t);const s=m.id;return{then:()=>{console.error(`There is no point in "await" before "watch" (scene: "${s}", event: "${t}").`)}}}class ne{constructor(e){h("\u{1F98A}",e),this.id=e,this.label="",this.align=le,this.flipped=!1,this.visible=!1,this.timeout,this.mood="normal",this.queue=[];let s="normal";const n=(...r)=>{if(Z){for(const{id:a,queue:o}of Object.values(he))if(o.length){console.error(`Unexpected state. Check the "await" before these words of ${a}:`,[...o]);return}}return this.proxy__(...r)};if(Object.assign(n,{$toLeft:()=>(this.setAlign("left"),u.characters[e].align="left",this.proxy_),$toRight:()=>(this.setAlign("right"),u.characters[e].align="right",this.proxy_),$setLabel:r=>(this.setLabel(r),u.characters[e].label=r,this.proxy_),$flipImage:()=>(this.setFlip(!this.flipped),u.characters[e].flipped=this.flipped,this.proxy_),then:()=>{console.error(`Seemingly useless "await" before ${this.id}'s handle. This error may be caused by:
1. Erroneous usage of "await" with syncronous methods like "$toLeft", "$toRight", "$setLabel".
2. Using quotes or double quotes instead of backticks in parenthesis-less notation.
3. Using a comma or semicolon before the first argument in parenthesis-less notation.`)}}),this.proxy=new Proxy(n,{get:(r,a)=>Object.hasOwn(r,a)?r[a]:(s=a,this.proxy__)}),this.proxy_=new Proxy(n,{apply:()=>{console.error("Direct function call in a method chain. Chaining of methods and function calls is prohibited.")}}),this.proxy__=new Proxy(n,{get:(r,a)=>{if(a==="then")return async(o,l)=>{const c=this.queue;this.queue=[],await this.say(s,...c).catch(l),s="normal",o()};console.error(`Once the call chain has started, property getting is not allowed. Requested property: "${a}".`)},apply:(r,a,o)=>(Array.isArray(o[0])&&Array.isArray(o[0].raw)&&(o=[Be(...o)]),this.queue.push(...o),this.proxy__)}),this.$el=b(i+"-character",i+"-character-id-"+e,i+"-character-align-"+this.align,i+"-character-inactive"),this.$portraits=b(i+"-character-portraits"),this.$label=b(i+"-label",i+"-label-id-"+e,i+"-label-hidden"),this.$el.append(this.$portraits,this.$label),Object.hasOwn(u.characters,e)){const r=u.characters[e];this.setLabel(r.label),this.setAlign(r.align),this.setFlip(r.flipped),h("\u21BB",r)}else u.characters[e]={}}setLabel(e=""){this.$label.innerText=e,this.label=e,e?this.visible&&this.$label.classList.remove(i+"-label-hidden"):this.$label.classList.add(i+"-label-hidden")}setAlign(e=le){e!==this.align&&(this.$el.classList.remove(i+"-character-align-"+this.align),this.$el.classList.add(i+"-character-align-"+e),this.align=e,this.visible&&this.updateTextboxAlign())}setFlip(e=!1){this.flipped=e,e?this.$el.classList.add(i+"-character-flipped"):this.$el.classList.remove(i+"-character-flipped")}setMood(e){return e!==this.mood?(this.$el.classList.remove(i+"-character-mood-"+this.mood),this.$el.classList.add(i+"-character-mood-"+e),this.mood=e,!0):!1}async show(e=this.mood){const s=this.setMood(e),n=!!p&&p===this,r=!!p&&p.align===this.align;let a=this.$portraits.querySelector("."+i+"-portrait-mood-"+e);a?a.classList.contains(i+"-portrait-hidden")&&this.$portraits.append(a):(a=b(i+"-portrait",i+"-portrait-mood-"+e,i+"-portrait-hidden"),this.$portraits.append(a),await new Promise(o=>{let l=w.getCharacterPortraitPath(this.id,e);Z&&(l+="?"+Math.random());const c=new Image;c.src=l,c.onload=()=>{a.style.backgroundImage=`url('${l}')`,o()},c.onerror=()=>{o()}})),n||(r?await p?.hide():p?.hide()),a.classList.contains(i+"-portrait-hidden")&&I(()=>{a.classList.remove(i+"-portrait-hidden")}),this.visible?await I(async()=>{await v(s?E.CHARACTER_MOOD_CHANGE:0);for(let o=0;o<this.$portraits.children.length-1;o++)this.$portraits.children[o].classList.add(i+"-portrait-hidden");this.updateTextboxAlign()}):(this.visible=!0,p=this,g.replaceChildren(),C.innerText="",S.append(this.$el),clearTimeout(this.timeout),d.onShow?.(this.id),await I(()=>{this.$el.classList.remove(i+"-character-inactive"),f.classList.remove(i+"-textbox-hidden");for(let o=f.classList.length-1;o>=0;o--){const l=f.classList[o];l.startsWith(i+"-textbox-of-")&&f.classList.remove(l)}f.classList.add(i+"-textbox-of-"+this.id),this.updateTextboxAlign()}),this.label?this.$label.classList.remove(i+"-label-hidden"):this.$label.classList.add(i+"-label-hidden"),await v(E.CHARACTER_SHOW))}async hide(){if(!this)await I(()=>{R||f.classList.add(i+"-textbox-hidden")});else if(this.visible){this.visible=!1,p=void 0,this.$el.classList.remove(i+"-character-mood-"+this.mood),this.$el.classList.add(i+"-character-inactive"),this.$label.classList.add(i+"-label-hidden");for(const e of this.$portraits.children)e.classList.add(i+"-portrait-hidden");await I(()=>{R||f.classList.add(i+"-textbox-hidden")}),d.onHide?.(this.id),this.timeout=setTimeout(()=>this.$el.remove(),5e3),await v(E.CHARACTER_HIDE)}}updateTextboxAlign(){this.align==="left"?(f.classList.remove(i+"-textbox-right"),f.classList.add(i+"-textbox-left")):(f.classList.remove(i+"-textbox-left"),f.classList.add(i+"-textbox-right"))}async say(e,...s){if(x(),R||Y){console.error("Message from "+(this?.id??"[print]")+' was ignored because the previous task was not finished. Check if you placed "await"s correctly.'),console.error("Message:",s);return}R=!0,S.style.pointerEvents="all",O.style.pointerEvents="none";const n=[];for(const r of s)Array.isArray(r)?n.push(...r):n.push(r);if(this)f.classList.remove(i+"-textbox-printed"),await this.show(e);else{const r=f.classList.contains(i+"-textbox-hidden"),a=r||!!p;p?.hide(),g.replaceChildren(),C.innerText="",f.classList.remove(i+"-textbox-left"),f.classList.remove(i+"-textbox-right"),f.classList.add(i+"-textbox-printed"),r&&f.classList.remove(i+"-textbox-hidden"),a&&await v(E.BEFORE_FIRST_PRINT)}for(let r=0;r<n.length;r++){if(typeof n[r]!="string")continue;let a=!1,o=0,l=Le,c=[];typeof n[r+1]=="number"&&(a=!0,o=n[r+1]);let y=n[r];if(y[0]==="["){const X=y.indexOf("]");c=y.slice(1,X).split(""),y=y.slice(X+1)}c.includes("!")&&(l=0),c.includes("~")&&(l=l*2),await Me(y,l,c.includes("+")),c.includes("+")&&j.pop(),j.push({id:this?.id??"[print]",label:this?.label??"[print]",text:g.innerText}),j.length>100&&j.shift(),a?g.classList.add(i+"-message-rendered-writing"):g.classList.add(i+"-message-rendered-stopped");let ve;const ze=new Promise((X,Ve)=>{ve=X,V=Ve}),Ee=()=>(k=!0,d.onStop?.(),ze);J=()=>{g.classList.remove(i+"-message-rendered-writing"),g.classList.remove(i+"-message-rendered-stopped"),ve()},q&&await v(E.BEFORE_SKIP_PRINTING),q?N(!0):a?(await v(o),N(!0)):F[" "]?(await v(E.BEFORE_IDLE_PROCEED),F[" "]?N(!0):await Ee()):await Ee()}R=!1}}async function Fe(...t){if(x(),h("\u{1F4CB}",t),R||Y){console.error('Cannot show selectable options because the previous task was not finished. Check if you placed "await"s correctly.'),console.error("Options:",t);return}if(t=t.filter(e=>typeof e=="string"||e instanceof Object),!!t.length)return Y=!0,k=!0,O.style.pointerEvents="all",T.replaceChildren(...t.map(e=>{const s=b(i+"-select-option");if(typeof e=="string")s.innerText=re(e);else{const[n,r]=Object.entries(e)[0];s.innerText=re(r),s.setAttribute("select-option-value",n)}return s})),T.classList.remove(i+"-select-hidden"),d.onShowOptions?.(),await v(E.BEFORE_SELECT_ACTIVE),new Promise((e,s)=>{V=s,z=e})}const pe=(t,...e)=>{const s=document.createElement(t);return s.classList.add(...e),s},b=pe.bind(null,"div"),me=pe.bind(null,"span");function I(t){return new Promise(e=>{requestAnimationFrame(()=>{requestAnimationFrame(async()=>{await t(),e()})})})}function We(){const t=[];return{onWatcherCreate(e){document.querySelectorAll(`[${$}="${e}"]`).forEach(s=>{s.classList.add(i+"-watched"),s.addEventListener("click",ie),t.push(s)})},onWatcherRemove(e){for(let s=t.length-1;s>=0;s--){const n=t[s];n.getAttribute($)===e&&(n.classList.remove(i+"-watched"),n.removeEventListener("click",ie),t.splice(s,1))}},onEventEnter(e){t.forEach(s=>{s.getAttribute($)===e?s.classList.add(i+"-watched-clicked"):s.classList.add(i+"-watched-clicked-other")})},onEventLeave(){t.forEach(e=>{e.classList.remove(i+"-watched-clicked"),e.classList.remove(i+"-watched-clicked-other")})}}}function ie(){U.notify(this.getAttribute($))}function qe(){document.removeEventListener("keydown",we),document.removeEventListener("keyup",ye),window.removeEventListener("popstate",be),$&&document.querySelectorAll(`[${$}]`).forEach(t=>{t.removeEventListener("click",ie),t.classList.remove(i+"-watched"),t.classList.remove(i+"-watched-clicked"),t.classList.remove(i+"-watched-clicked-other")})}function He(t,...e){if(!Object.hasOwn(A,t)){console.error("Trying to call unknown scene:",t);return}if(W>99){console.error(`Scene "${t}" cannot be called: stack size limit reached (${W}).`);return}return W+=1,h("\u{1F4AC}",t),(async()=>{d.onSceneEnter?.(t,!1);const s=await A[t].cb(ue,...e);return d.onSceneLeave?.(t,!1),W-=1,W||h("\u26F0\uFE0F",m?.id,"\u21A9"),s})()}function De(...t){return ne.prototype.say.call(null,null,...t)}function Ke(){return p?p.hide():ne.prototype.hide.call(null)}function v(t){return new Promise((e,s)=>{V=s,setTimeout(e,t)})}function re(t){if(_!==-1&&typeof t=="string"){const e=t.split(Ae);return _<e.length?e[_]:e[0]}return t}function Be(t,...e){let s="";for(let n=0;n<t.length;n++)s+=t[n],n<t.length-1&&(s+=`${e[n]}`);return s}function Me(t,e,s){const[n,r]=Je(re(t));return s||(g.replaceChildren(),C.innerText=n),new Promise(a=>{const o=l=>{if(q||e===0){const c=ge(n.slice(l));g.append(...c),s||(C.innerText="");for(let y=0;y<c.length;y++)d.onType?.(n[l+y],c[y],r[l+y],!0);a()}else l<n.length?setTimeout(()=>{const c=ge(n[l])[0];g.append(c),s||(C.innerText=n.slice(l+1)),d.onType?.(n[l],c,r[l],!1),o(l+1)},te?0:e):a()};o(0)})}function ge(t){const e=[];for(const s of t){const n=document.createElement("span");n.innerText=s,e.push(n)}return e}function Ge(t,e=0){if(!t.slice(e).includes("::"))return!1;const s=/[!?.,;:\s"()\]]/;let n,r;for(let a=e;a<t.length;a++)if(t[a]==="[")n=a;else if(t[a]===":"&&t[a+1]===":"){for(let o=a+2;o<=t.length;o++)if(o===t.length||t[o]==="]"||n===void 0&&s.test(t[o])){const l=n??r;return[l!==void 0?l+1:e,a+2,o]}}else n===void 0&&s.test(t[a])&&(r=a);return!1}function Ue(t){const e=[];let s=0;for(;;){const n=Ge(t,s);if(n)e.push(n),s=n[2]+1;else return e}}function Je(t){const e=Ue(t);if(!e.length)return[t,[]];const s=t.split(""),n=Array(t.length).fill(void 0);for(const[r,a,o]of e){const l=t.slice(r,a-2);for(let c=r;c<a;c++)s[c]=!1,n[c]=!1;for(let c=a;c<o;c++)n[c]=l}for(let r=0;r<s.length;r++)(s[r]==="["||s[r]==="]")&&(s[r]=!1,n[r]=!1);return[s.filter(r=>r!==!1).join(""),n.filter(r=>r!==!1)]}function h(...t){Z&&console.log(...t.map(e=>e===fe?u.$:e))}const we=({key:t})=>{if(!F[t])switch(F[t]=!0,t){case" ":te=!0,N();break;case"Control":N(),q=!0;break}},ye=({key:t})=>{switch(delete F[t],t){case" ":te=!1;break;case"Control":q=!1;break}},be=t=>{w.onUserNavigates?.()};return document.addEventListener("keydown",we),document.addEventListener("keyup",ye),window.addEventListener("popstate",be),U=new Ie,Object.assign(ee,{event:(t,...e)=>{U.notify(t,...e)},getHistory:()=>j,clearSaveSlot:(t="autosave")=>{U.clearSaveSlot(t)},remove:()=>{M=!0,qe(),H.remove();for(const t of Object.keys(d))d[t]=null;for(const t of Object.keys(w))w[t]=null;V?.(G)},sleep:v,log:h}),ee};
