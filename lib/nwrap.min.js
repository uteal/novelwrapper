/*! NovelWrapper v0.5.3 | (c) 2026 uteal | MIT License *//**
 * Makes a new novel from the scenes given. Returns a handle with a set of useful methods.
 * @param {string} novelTag A novel-specific name used when saving or restoring a game state.
 * @param {(function|function[])} factories A function or array of functions that return dictionaries of novel scenes.
 * @param {object} params Initial params.
 * @param {object} params.$ Initial game state. Should be JSON-serializable. Empty object by default.
 * @param {object} params.ext A helper object for passing custom functions or data to scenes.
 * @param {(object|object[])} params.callbacks Callbacks for standard events in form of object or array of objects.
 * @param {boolean} params.devMode Allows the engine to output logs. Essential during development.
 * @param {string} params.cssPrefix Engine will use this when searching for CSS styles. Default is "novel".
 * @param {string} params.watchedAttr The engine will track elements with this attribute, listen to their events and apply CSS classes.
 * @param {string} params.imagesPath Path to the folder with portraits of the novel's characters.
 * @param {string} params.imagesType File extension of the novel's character portraits. Default is "png".
 * @param {(string|null)} params.firstScene Entry point of the novel, defaults to "start". Set to null to prevent the game from starting automatically.
 * @param {string} params.restoreFromSlot The game tries to load from the specified slot, "autosave" by default.
 * @param {boolean} params.startOver Should the game ignore the save data and start over?
 * @param {boolean} params.noSaveLoad Do not save or load the game state. Default is false.
 * @param {boolean} params.noKeyboard Ignore keyboard controls. Default is false.
 * @param {boolean} params.useLocationHash If true, the game will store its state as the hash property of the window location object.
 * @param {(string|HTMLElement)} params.appendTo Where the novel element should be placed. Defaults to document.body.
 * @param {object} params.implementations An object with functions that will override certain engine methods. They run in the context of this object.
 * @param {object} params.delays Engine animation delays, for deep customization. See the engine file for a list of them.
 * @param {('left'|'right')} params.defaultAlign Starting alignment of each character. Default is "right".
 * @param {RegExp} params.multiLangSplitRegex Delimiter of multilingual strings. /\s+>>\s+/ by default.
 * @param {number} params.language Which part of the split multilingual string should be shown. Default: -1 (i.e. no translation).
 * @preserve
 */export default(oe,H,{$:Ue={},ext:Ge={},callbacks:Y=[],devMode:X=!0,cssPrefix:r="novel",watchedAttr:D=void 0,imagesPath:Re="./images/",imagesType:Ke="png",firstScene:Je="start",restoreFromSlot:Ve="autosave",startOver:ze=!1,noSaveLoad:me=!1,noKeyboard:ke=!1,useLocationHash:ae=!1,appendTo:le=document.body,implementations:Ye={},delays:Xe={},defaultAlign:Pe="right",multiLangSplitRegex:Qe=/\s+>>\s+/,language:ye=-1}={})=>{if(!H||Array.isArray(H)&&!H.length)throw new Error("You should provide at least one scene factory function.");const Ie="Hinata",K=matchMedia("(pointer: coarse)").matches?"touchend":"click",Ze=Re+(Re.endsWith("/")?"":"/"),_e=Ke.toLowerCase(),et=50,B="nw-page-link";let Q=!1,je;const tt=new Promise(t=>{je=t}),ce="AbortSignal",T=()=>{if(Q)throw ce},we={},Z=new Map,f={},J={},be={},he=[],ve={};let M,b,v,Ne,fe,ue,de,_,ee=0,te=!1,U=!1,se=!1,R=!1,pe=!0,k=!1,ne,A,O,q,p,u,V,P;const L={CHARACTER_SHOW:350,CHARACTER_HIDE:350,CHARACTER_MOOD_CHANGE:100,BEFORE_SELECT_ACTIVE:350,BEFORE_DIALOGS_ACTIVE:250,BEFORE_STORIES_ACTIVE:250,AFTER_OPTION_CLICK:250,BEFORE_FIRST_NOTE:500,BEFORE_IDLE_PROCEED:400,PAGE_SHOW:500,PAGE_HIDE:500},d={onShow:null,onHide:null,onStopTyping:null,onTaggedPart:null,onRenderFragments:null,onStopWriting:null,onSceneEnter:null,onSceneLeave:null,onWatcherCreate:null,onWatcherRemove:null,onEventEnter:null,onEventLeave:null,onShowOptions:null,onOptionClick:null,onStateChange:null,onGameEnd:null},S={getCharacterPortraitPath(t,e){return`${Ze}${t}/${e}.${_e}`},createKey(t,e){return`${t}(${e})`},writeState(t,e){if(ae){let s={};try{s=JSON.parse(decodeURIComponent(window.location.hash).slice(1))}catch{}s[t]=e,window.history.pushState(void 0,void 0,"#"+JSON.stringify(s))}else localStorage.setItem(t,JSON.stringify(e))},readState(t){if(l("\u21BB",t),ae){let e={};try{e=JSON.parse(decodeURIComponent(window.location.hash).slice(1))}catch{}return e[t]}else{let e;try{e=JSON.parse(localStorage.getItem(t))}catch{}return e}},clearSavedState(t){if(l("\u{1F5D1}\uFE0F",t),ae){let e={};try{e=JSON.parse(decodeURIComponent(window.location.hash).slice(1))}catch{}delete e[t],window.history.replaceState(void 0,void 0,"#"+JSON.stringify(e))}else localStorage.removeItem(t)},onUserNavigates(){ae&&window.history.go(0)}},Ee=new Proxy(f,{set(t,e,s){return t.$[e]=s,d.onStateChange?.(e,s),!0},get(t,e){return t.$[e]}}),We=new Proxy(be,{get(t,e){return Object.hasOwn(t,e)||(t[e]=new xe(e)),t[e].proxy}}),re=(t,e=!1)=>{if(!Q){if(fe){if(R||e){R=!1;const s=fe;fe=null,s()}}else if(t?.target.hasAttribute(B)){const s=t.target.getAttribute(B);s[0]==="@"?M.runScene(s.slice(1)):s[0]==="&"&&M.notify(s.slice(1))}}},ie=(t,e=!1)=>{if(!Q&&(R||e)&&ue){R=!1;const s=ue;ue=null,s()}},qe=async(t,e=void 0)=>{if(Q||!R||!de)return;let s,i;if(typeof e=="number"){if(i=e,s=P.querySelectorAll("."+r+"-select-option")[e],!s)return}else{if(s=t.target,!s?.classList.contains(r+"-select-option"))return;i=[...P.querySelectorAll("."+r+"-select-option")].findIndex(a=>s===a)}R=!1,d.onOptionClick?.();const n=s.getAttribute("select-option-value")??i;Z.clear(),Z.set(String(n),!0),Z.set("__value__",n),P.classList.add(r+"-select-hidden");const o=de;de=null,l("\u{1F449}",s.innerText.replaceAll(`
`," ")),await w(L.AFTER_OPTION_CLICK),se=!1,o(n)},gt=t=>"\x1B[30m"+t+"\x1B[0m",mt=t=>"\x1B[31m"+t+"\x1B[0m",yt=t=>"\x1B[32m"+t+"\x1B[0m",wt=t=>"\x1B[33m"+t+"\x1B[0m",bt=t=>"\x1B[34m"+t+"\x1B[0m",vt=t=>"\x1B[35m"+t+"\x1B[0m",Et=t=>"\x1B[36m"+t+"\x1B[0m",xt=t=>"\x1B[37m"+t+"\x1B[0m",Lt=t=>"\x1B[90m"+t+"\x1B[0m";class st{constructor(){Object.assign(L,Xe),ne=E(r+"-container",r+"-layer"),A=E(r+"-stories",r+"-layer"),p=E(r+"-page",r+"-page-hidden"),O=E(r+"-dialogs",r+"-layer"),u=E(r+"-textbox",r+"-textbox-hidden"),V=E(r+"-messages"),q=E(r+"-choices",r+"-layer"),P=E(r+"-select",r+"-select-hidden"),ne.append(A,O,q),A.append(p),q.append(P),O.append(u),u.append(V),A.addEventListener(K,re),O.addEventListener(K,ie),P.addEventListener(K,qe),ne.style.pointerEvents="none",Array.isArray(Y)||(Y=[Y]),D&&Y.push(ct()),this.setCallbacks(Y);for(const[s,i]of Object.entries(Ye))Object.hasOwn(S,s)?S[s]=i:console.error(`Unknown name for implementation given: "${s}".`);this.getScenes(),typeof le=="string"&&(le=document.querySelector(le)),le.append(ne);const e=!ze&&this.loadState(Ve);e&&e.version===Ie?Object.assign(f,e):(l("\u{1F3AC}",oe),Object.assign(f,this.createNewState()),Object.assign(f.$,Ue)),l("\u{1F4E6}",structuredClone(f)),je(we)}setCallbacks(e){const s=Object.fromEntries(Object.keys(d).map(i=>[i,[]]));for(const i of e)for(const[n,o]of Object.entries(i)){if(!Object.hasOwn(s,n)){console.error("Unknown callback:",n);continue}s[n].push(o)}for(const[i,n]of Object.entries(s))n.length>0&&(d[i]=n.length===1?n[0]:function(...o){n.forEach(a=>a.apply(this,o))})}getScenes(){Array.isArray(H)||(H=[H]);for(const e of H)Object.entries(e({$:Ee,_:ot,write:at,erase:Fe,when:rt,call:ut,note:dt,mute:He,sleep:w,save:this.saveState,log:l,ext:Ge})).forEach(([s,i])=>{Object.hasOwn(J,s)?console.error("Scene redeclaration:",s):J[s]=new nt(s,i)})}saveState(e="autosave"){if(T(),me)return;const s=S.createKey?.(oe,e);return S.writeState?.(s,structuredClone(f))}loadState(e){if(T(),me)return;const s=S.createKey?.(oe,e);return S.readState?.(s)}clearSaveSlot(e){if(T(),me)return;const s=S.createKey?.(oe,e);return S.clearSavedState?.(s)}createNewState(){return{scene:Je,args:[],$:{},characters:{},version:Ie}}async runScene(e,s=[],i=!0){if(T(),s.length?l("\u26F0\uFE0F",e,s):l("\u26F0\uFE0F",e),b&&b.end(),e?.[0]==="~"?e=e.slice(1):(await Promise.all([Fe(),He()]),Object.values(be).forEach(o=>{Object.hasOwn(f.characters,o.id)&&(o.setAlign(f.characters[o.id].align),o.setLabel(f.characters[o.id].label))})),!Object.hasOwn(J,e)){console.error("Trying to run unknown scene:",e);return}b=J[e],f.scene=e,f.args=structuredClone(s),i&&this.saveState("autosave"),Z.clear(),d.onSceneEnter?.(e,!0);let n;try{n=structuredClone(await b.run(...structuredClone(s)))}catch(o){if(o===ce){l("\u270B","The game was manually interrupted."),l("\u{1FA82}","Emergency exiting.");return}else throw o}d.onSceneLeave?.(e,!0),typeof n=="string"?setTimeout(()=>this.runScene(n)):Array.isArray(n)&&typeof n[0]=="string"?setTimeout(()=>this.runScene(n[0],n.slice(1))):n!==void 0&&(l("\u{1F3C1}","Game ended."),d.onGameEnd?.(n))}async notify(e,...s){if(T(),l("\u26A1",e),!b){console.error(`Event "${e}" occured while no scene is active`);return}if(!pe){console.error(`Event "${e}" occured while the script flow was not ended.`);return}const i=b.watchers.find(n=>n.event===e);if(!i){l("\u{1F965}","No such watcher.");return}if(!i.cb){l("\u{1F34B}","Callback not set.");return}if(i){pe=!1,p.classList.remove(r+"-page-written"),d.onEventEnter?.(e,...s);let n;try{n=structuredClone(await i.cb(...s))}catch(o){if(o===ce){l("\u270B","The game was manually interrupted."),l("\u{1FA82}","Emergency exiting.");return}else throw o}d.onEventLeave?.(e,n),typeof n=="string"||Array.isArray(n)&&typeof n[0]=="string"?Ne(n):(n===!1&&b.removeWatcher(e),v?.hide(),A.style.pointerEvents=Ae()?"all":"none",O.style.pointerEvents="none",q.style.pointerEvents="none",p.classList.add(r+"-page-written"),pe=!0,l("\u26F0\uFE0F",b.id,"\u21A9"))}}}class nt{watchers=[];constructor(e,s){this.id=e,this.cb=s}async run(...e){let s=await this.cb(We,...e);return s===void 0&&(pe=!0,v?.hide(),A.style.pointerEvents=Ae()?"all":"none",O.style.pointerEvents="none",q.style.pointerEvents="none",p.classList.add(r+"-page-written"),this.watchers.length?s=await new Promise(i=>{Ne=i}):Ae("@")||l("\u{1F6A7}","The game has stalled.")),s}removeWatcher(e){const s=this.watchers.findIndex(i=>i.event===e);s!==-1&&(this.watchers.splice(s,1),ft(e),d.onWatcherRemove?.(e),l("\u{1F9F9}",e))}end(){this.watchers.forEach(({event:e})=>{d.onWatcherRemove?.(e)}),this.watchers=[]}}const rt=(t,e)=>{if(T(),b.watchers.some(i=>i.event===t)){console.error(`Multiple watchers of the same event (${t}) not allowed at scene (${b.id})`);return}l("\u{1F4CC}",t),b.watchers.push({event:t,cb:e}),d.onWatcherCreate?.(t);const s=b.id;return{then:()=>{console.error(`There is no point in "await" before "when" (scene: "${s}", event: "${t}").`)}}};class xe{constructor(e){l("\u{1F98A}",e),this.id=e,this.label="",this.align=Pe,this.visible=!1,this.timeout,this.mood="normal",this.queue=[];let s="normal";const i=(...n)=>{if(X){for(const{id:o,queue:a}of Object.values(be))if(a.length){console.error(`Unexpected state. Check the "await" before these words of ${o}:`,[...a]);return}}return this.proxy__(...n)};if(Object.assign(i,{toLeft:()=>(this.setAlign("left"),this.proxy_),toRight:()=>(this.setAlign("right"),this.proxy_),setLabel:n=>(this.setLabel(n),this.proxy_),$toLeft:()=>(Object.hasOwn(f.characters,e)||(f.characters[e]={}),f.characters[e].align="left",this.setAlign("left"),this.proxy_),$toRight:()=>(Object.hasOwn(f.characters,e)||(f.characters[e]={}),f.characters[e].align="right",this.setAlign("right"),this.proxy_),$setLabel:n=>(Object.hasOwn(f.characters,e)||(f.characters[e]={}),f.characters[e].label=n,this.setLabel(n),this.proxy_),then:()=>{console.error(`Seemingly useless "await" before ${this.id}'s handle. This error may be caused by:
1. Erroneous usage of "await" with syncronous methods.
2. Using quotes or double quotes instead of backticks in parenthesis-less notation.
3. Using a comma or semicolon before the first argument in parenthesis-less notation.`)}}),this.proxy=new Proxy(i,{get:(n,o)=>Object.hasOwn(n,o)?n[o]:(s=o,this.proxy__)}),this.proxy_=new Proxy(i,{apply:()=>{console.error("Direct function call in a method chain. Chaining of methods and function calls is prohibited.")}}),this.proxy__=new Proxy(i,{get:(n,o)=>{if(o==="then")return async(a,c)=>{const h=this.queue;this.queue=[],await this.say(s,...h).catch(c),s="normal",a()};console.error("Once the call chain has started, property getting is not allowed. Requested property: "+o)},apply:(n,o,a)=>(Array.isArray(a[0])&&Array.isArray(a[0].raw)&&(a=[Ce(...a)]),this.queue.push(...a),this.proxy__)}),this.$el=E(r+"-character",r+"-character-id-"+e,r+"-character-align-"+this.align,r+"-character-inactive"),this.$portraits=E(r+"-character-portraits"),this.$label=E(r+"-label",r+"-label-of-"+e,r+"-label-hidden"),this.$el.append(this.$portraits,this.$label),Object.hasOwn(f.characters,e)){const n=f.characters[e];this.setAlign(n.align),this.setLabel(n.label),l("\u21BB",n)}}setAlign(e=Pe){e!==this.align&&(this.$el.classList.remove(r+"-character-align-"+this.align),this.$el.classList.add(r+"-character-align-"+e),this.align=e,this.visible&&this.updateTextboxAlign())}setLabel(e=""){this.label!==e&&(this.label=e,this.$label.innerText=e,e?this.visible&&this.$label.classList.remove(r+"-label-hidden"):this.$label.classList.add(r+"-label-hidden"))}setMood(e){return e!==this.mood?(this.$el.classList.remove(r+"-character-mood-"+this.mood),this.$el.classList.add(r+"-character-mood-"+e),this.mood=e,!0):!1}async show(e=this.mood){const s=this.setMood(e),i=!!v&&v===this,n=!!v&&v.align===this.align;let o=this.$portraits.querySelector("."+r+"-portrait-mood-"+e);o?o.classList.contains(r+"-portrait-hidden")&&this.$portraits.append(o):(o=E(r+"-portrait",r+"-portrait-mood-"+e,r+"-portrait-hidden"),this.$portraits.append(o),await new Promise(a=>{let c=S.getCharacterPortraitPath(this.id,e);X&&(c+="?"+Math.random());const h=new Image;h.src=c,h.onload=()=>{o.style.backgroundImage=`url('${c}')`,a()},h.onerror=()=>{a()}})),i||(n?await v?.hide():v?.hide()),o.classList.contains(r+"-portrait-hidden")&&z(()=>{o.classList.remove(r+"-portrait-hidden")}),this.visible?await z(async()=>{await w(s?L.CHARACTER_MOOD_CHANGE:0);for(let a=0;a<this.$portraits.children.length-1;a++)this.$portraits.children[a].classList.add(r+"-portrait-hidden");this.updateTextboxAlign()}):(this.visible=!0,v=this,V.replaceChildren(),O.append(this.$el),clearTimeout(this.timeout),d.onShow?.(this.id),await z(()=>{this.$el.classList.remove(r+"-character-inactive"),u.classList.remove(r+"-textbox-hidden");for(let a=u.classList.length-1;a>=0;a--){const c=u.classList[a];c.startsWith(r+"-textbox-of-")&&u.classList.remove(c)}u.classList.add(r+"-textbox-of-"+this.id),this.updateTextboxAlign()}),this.label?this.$label.classList.remove(r+"-label-hidden"):this.$label.classList.add(r+"-label-hidden"),await w(L.CHARACTER_SHOW))}async hide(){if(!this)await z(()=>{U||u.classList.add(r+"-textbox-hidden")});else if(this.visible){this.visible=!1,v=void 0,this.$el.classList.remove(r+"-character-mood-"+this.mood),this.$el.classList.add(r+"-character-inactive"),this.$label.classList.add(r+"-label-hidden");for(const e of this.$portraits.children)e.classList.add(r+"-portrait-hidden");await z(()=>{U||u.classList.add(r+"-textbox-hidden")}),d.onHide?.(this.id),this.timeout=setTimeout(()=>this.$el.remove(),5e3),await w(L.CHARACTER_HIDE)}}updateTextboxAlign(){this.align==="left"?(u.classList.remove(r+"-textbox-right"),u.classList.add(r+"-textbox-left")):(u.classList.remove(r+"-textbox-left"),u.classList.add(r+"-textbox-right"))}async say(e,...s){if(T(),te||U||se){console.error("Message from "+(this?.id??"[note]")+' was ignored because the previous task was not finished. Check if you placed "await"s correctly.'),console.error("Message:",s);return}U=!0,A.style.pointerEvents="none",O.style.pointerEvents="all",q.style.pointerEvents="none";const i=[];for(const n of s)Array.isArray(n)?i.push(...n):i.push(n);if(this)u.classList.remove(r+"-textbox-note"),await this.show(e);else{const n=u.classList.contains(r+"-textbox-hidden"),o=n||!!v;v?.hide(),V.replaceChildren();for(let a=u.classList.length-1;a>=0;a--){const c=u.classList[a];c.startsWith(r+"-textbox-of-")&&u.classList.remove(c)}u.classList.remove(r+"-textbox-left"),u.classList.remove(r+"-textbox-right"),u.classList.add(r+"-textbox-note"),n&&u.classList.remove(r+"-textbox-hidden"),o&&await w(L.BEFORE_FIRST_NOTE)}for(let n=0;n<i.length;n++){if(typeof i[n]!="string")continue;let o=!1,a=0;typeof i[n+1]=="number"&&(o=!0,a=i[n+1]);const[c,h]=$e(Oe(i[n]));await Le(...Te(c,h),!1,x=>{for(const m of x)m.classList.add(r+"-message",r+"-message-"+e);V.replaceChildren(...x)}),he.push({id:this?.id??"[note]",label:this?.label??"[note]",text:V.innerText.replaceAll(`
`," ")}),he.length>100&&he.shift();let g;const I=new Promise((x,m)=>{g=x,_=m}),y=()=>(R=!0,d.onStopTyping?.(),I);ue=()=>{u.classList.remove(r+"-textbox-waiting"),g()},k&&await w(L.BEFORE_IDLE_PROCEED),k?ie(null,!0):o?(await w(a),ie(null,!0)):(await w(L.BEFORE_DIALOGS_ACTIVE),u.classList.add(r+"-textbox-waiting"),k?ie(null,!0):await y())}U=!1}}const Le=(t,e,s,i,n)=>{const o=r+(i?"-passageFragment":"-messageFragment");s.length>t.length&&console.error("Do not put a pause at the end of the text (it is ignored).");for(let y=t.length-1;y>=0;y--)(t[y]===" "||t[y]===`
`)&&(s[y]!==0&&console.error("Do not insert a pause before spaces or new lines (it is ignored)."),e.splice(y,1),s.splice(y,1));const a=new Map,c=[];let h=0,g=0;const I=[];for(const y of t.split(/\n+/)){const x=E(r+"-paragraph");for(const m of y.replace(/^ +| +$/g,"").split(/ +/)){const j=ge(r+"-word"),C=s.slice(h,h+m.length),$=e.slice(h,h+m.length);let F,N,G;for(let W=0;W<m.length;W++)W===0||C[W]!==0?(F=ge(o),j.append(F),g+=C[W],a.has(g)||a.set(g,[]),a.get(g).push(F),N=ge(),F.append(N),G=$[W],G&&c.push([N,G])):G!==$[W]&&(N=ge(),F.append(N),G=$[W],G&&c.push([N,G])),N.innerText+=m[W];x.append(j),h+=m.length}I.push(x)}for(const[y,x]of c){const m=x?.trim().split(/\s*,\s*/)??[];if(i)for(let j=m.length-1;j>=0;j--){const C=m[j];(C[0]==="@"||C[0]==="&")&&(y.classList.add(r+"-link-"+(C[0]==="@"?"scene":"event")),y.setAttribute(B,C),m.splice(j,1))}m.length&&d.onTaggedPart?.(y,m)}return n(I),new Promise(y=>{const x=[...a.entries()],m=(j,C)=>{for(let $=j;$<x.length;$++){const F=x[$][0]-(x[$-1]?.[0]??0);if(!C&&!k&&F>0){setTimeout(()=>m($,!0),F);return}x[$][1].forEach(N=>N.classList.add(o+"-rendered")),C=!1,d.onRenderFragments?.(!!i)}y()};z(()=>m(0,!1))})},it=async(...t)=>{if(T(),l("\u{1F4CB}",t),te||U||se){console.error('Cannot show selectable options because the previous task was not finished. Check if you placed "await"s correctly.'),console.error("Options:",t);return}if(t=t.filter(e=>typeof e=="string"||e instanceof Object),!!t.length){se=!0,R=!0,A.style.pointerEvents="none",O.style.pointerEvents="none",q.style.pointerEvents="all",P.replaceChildren();for(let e of t){const s=E(r+"-select-option");if(typeof e!="string"){const i=Object.entries(e)[0];s.setAttribute("select-option-value",i[0]),e=i[1]}Le(...Te(...$e(Oe(e))),!1,i=>{for(const n of i)n.style.pointerEvents="none";s.append(...i)}),P.append(s)}return P.classList.remove(r+"-select-hidden"),d.onShowOptions?.(),await w(L.BEFORE_SELECT_ACTIVE),new Promise((e,s)=>{_=s,de=e})}},ot=new Proxy(it,{set(){console.error("This object is readonly.")},get(t,e){return Z.get(e)}}),at=(()=>{let t=[],e="normal";const s=new Proxy(()=>{},{get:(i,n)=>{if(n==="then")return async(o,a)=>{const c=t;t=[],await lt(e,...c).catch(a),e="normal",o()};console.error("Once the call chain has started, property getting is not allowed. Requested property: "+n)},apply:(i,n,o)=>(Array.isArray(o[0])&&Array.isArray(o[0].raw)&&(o=[Ce(...o)]),t.push(...o),s)});return new Proxy(()=>{},{get:(i,n)=>{if(n==="then")console.error(`Seemingly useless "await" before write function. This error may be caused by:
- Using quotes or double quotes instead of backticks in parenthesis-less notation.
- Using a comma or semicolon before the first argument in parenthesis-less notation.`);else return e=n,s},apply:(i,n,o)=>{if(X&&t.length){console.error('Unexpected state. Check the "await" before these words:',[...t]);return}return s(...o)}})})(),lt=async(t,...e)=>{if(T(),te||U||se){console.error('Writing task was ignored because the previous task was not finished. Check if you placed "await"s correctly.'),console.error("Skipped text:",e);return}te=!0,A.style.pointerEvents="all",O.style.pointerEvents="none",q.style.pointerEvents="none";const s=[];for(const i of e)Array.isArray(i)?s.push(...i):s.push(i);p.classList.contains(r+"-page-hidden")&&(p.classList.remove(r+"-page-hidden"),await w(L.PAGE_SHOW));for(let i=0;i<s.length;i++){if(typeof s[i]!="string")continue;let n=!1,o=0;typeof s[i+1]=="number"&&(n=!0,o=s[i+1]),await Le(...Te(...$e(Oe(s[i]))),!0,g=>{for(const I of g)I.classList.add(r+"-passage",r+"-passage-"+t),p.append(I),p.children.length>et&&p.children[0].remove();p.scrollHeight>p.clientHeight&&p.scrollTo({top:p.scrollHeight,left:0,behavior:"smooth"})});let a;const c=new Promise((g,I)=>{a=g,_=I}),h=()=>(R=!0,d.onStopWriting?.(),c);fe=()=>{p.classList.remove(r+"-page-waiting"),a()},k&&await w(L.BEFORE_IDLE_PROCEED),k?re(null,!0):n?(await w(o),re(null,!0)):(await w(L.BEFORE_STORIES_ACTIVE),p.classList.add(r+"-page-waiting"),k?re(null,!0):await h())}te=!1},Fe=async()=>{p.classList.contains(r+"-page-hidden")||(p.classList.add(r+"-page-hidden"),await w(L.PAGE_HIDE)),p.replaceChildren(),p.classList.remove(r+"-page-written"),A.style.pointerEvents="none"},E=(...t)=>{const e=document.createElement("div");return t.length&&e.classList.add(...t),e},ge=(...t)=>{const e=document.createElement("span");return t.length&&e.classList.add(...t),e},z=t=>new Promise(e=>{requestAnimationFrame(()=>{requestAnimationFrame(async()=>{await t(),e()})})});function Se(){M.notify(this.getAttribute(D))}const ct=()=>{const t=[];return{onWatcherCreate(e){document.querySelectorAll(`[${D}="${e}"]`).forEach(s=>{s.classList.add(r+"-watched"),s.addEventListener(K,Se),t.push(s)})},onWatcherRemove(e){for(let s=t.length-1;s>=0;s--){const i=t[s];i.getAttribute(D)===e&&(i.classList.remove(r+"-watched"),i.removeEventListener(K,Se),t.splice(s,1))}},onEventEnter(e){t.forEach(s=>{s.getAttribute(D)===e?s.classList.add(r+"-watched-clicked"):s.classList.add(r+"-watched-clicked-other")})},onEventLeave(){t.forEach(e=>{e.classList.remove(r+"-watched-clicked"),e.classList.remove(r+"-watched-clicked-other")})}}},ht=()=>{document.removeEventListener("keydown",De),document.removeEventListener("keyup",Be),window.removeEventListener("popstate",Me),D&&document.querySelectorAll(`[${D}]`).forEach(t=>{t.removeEventListener(K,Se),t.classList.remove(r+"-watched"),t.classList.remove(r+"-watched-clicked"),t.classList.remove(r+"-watched-clicked-other")})},ft=t=>{for(const e of p.querySelectorAll(`[${B}="@${t}"]`))e.removeAttribute(B),e.classList.remove(r+"-link-event")},Ae=(t=void 0)=>{for(const e of p.querySelectorAll(`[${B}]`))if(!t||e.getAttribute(B).startsWith(t))return!0;return!1},ut=(t,...e)=>{if(!Object.hasOwn(J,t)){console.error("Trying to call unknown scene:",t);return}if(ee>99){console.error(`Scene "${t}" cannot be called: stack size limit reached (${ee}).`);return}return ee+=1,e.length?l("\u{1F4AC}",t,e):l("\u{1F4AC}",t),(async()=>{d.onSceneEnter?.(t,!1);const s=await J[t].cb(We,...e);return d.onSceneLeave?.(t,!1),ee-=1,ee||l("\u26F0\uFE0F",b?.id,"\u21A9"),s})()},dt=(()=>{let t=[],e="normal";const s=new Proxy(()=>{},{get:(i,n)=>{if(n==="then")return async(o,a)=>{const c=t;t=[],await xe.prototype.say.call(null,e,...c).catch(a),e="normal",o()};console.error("Once the call chain has started, property getting is not allowed. Requested property: "+n)},apply:(i,n,o)=>(Array.isArray(o[0])&&Array.isArray(o[0].raw)&&(o=[Ce(...o)]),t.push(...o),s)});return new Proxy(()=>{},{get:(i,n)=>{if(n==="then")console.error(`Seemingly useless "await" before note function. This error may be caused by:
- Using quotes or double quotes instead of backticks in parenthesis-less notation.
- Using a comma or semicolon before the first argument in parenthesis-less notation.`);else return e=n,s},apply:(i,n,o)=>{if(X&&t.length){console.error('Unexpected state. Check the "await" before these words from "note":',[...t]);return}return s(...o)}})})(),He=()=>v?v.hide():xe.prototype.hide.call(null),w=t=>new Promise((e,s)=>{_=s,setTimeout(e,t)}),Oe=t=>{if(ye!==-1&&typeof t=="string"){const e=t.split(Qe);return ye<e.length?e[ye]:e[0]}return t},Ce=(t,...e)=>{let s="";for(let i=0;i<t.length;i++)s+=t[i],i<t.length-1&&(s+=`${e[i]}`);return s},$e=t=>{const e=t.split(""),s=new Array(t.length).fill(0);let i=0;for(const{"0":n,"1":o,index:a}of t.matchAll(/\[(\d+)\]/g))e.splice(a-i,n.length),s.splice(a-i,n.length),s[a-i]=+o,i+=n.length;return[e.join(""),s]},Te=(t,e=[])=>{const s=t.split(""),i=new Array(t.length).fill(void 0);let n=0;for(const o of t.matchAll(/\[(.*?)::(.*?)\]/gs)){const{"1":a,"2":c,index:h}=o;e.splice(h-n+1,a.length+2),s.splice(h-n+1,a.length+2),i.splice(h-n+1,a.length+2);for(let g=h-n+1;g<h-n+1+c.length;g++)i[g]=a;n+=a.length+2}n=0;for(const o of s.join("").matchAll(/([\p{L}\d_#&@~]*)::([\p{L}\d_*\-]*)/gu)){const{"1":a,"2":c,index:h}=o;e.splice(h-n+1,a.length+2),s.splice(h-n,a.length+2),i.splice(h-n,a.length+2);for(let g=h-n;g<h-n+c.length;g++)i[g]=a;n+=a.length+2}for(let o=s.length-1;o>=0;o--){const a=s[o];(a==="["||a==="]")&&(s.splice(o,1),i.splice(o,1),e.splice(a==="["?o+1:o,1))}return[s.join(""),i,e]},l=(...t)=>{X&&console.log(...t.map(e=>e===Ee?f.$:e))},De=({key:t})=>{if(!ke&&!ve[t])switch(ve[t]=!0,t){case" ":re(),ie(),k=!0;break;case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":qe(null,t-1);break}},Be=({key:t})=>{ke||(delete ve[t],t===" "&&(k=!1))},Me=t=>{S.onUserNavigates?.()};return document.addEventListener("keydown",De),document.addEventListener("keyup",Be),window.addEventListener("popstate",Me),M=new st,Object.assign(we,{run(){return!b&&f.scene&&M.runScene(f.scene,f.args,!1),we},event:(t,...e)=>{M.notify(t,...e)},clearSaveSlot:(t="autosave")=>M.clearSaveSlot(t),remove:()=>{Q=!0,ht(),ne.remove();for(const t of Object.keys(d))d[t]=null;for(const t of Object.keys(S))S[t]=null;_?.(ce)},getHistory:()=>he,$:Ee,sleep:w,log:l}),tt};
