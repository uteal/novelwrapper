/*! NovelWrapper v0.4.7 | (c) 2025 uteal | MIT License *//**
 * Makes a new novel from the scenes given. Returns a handle with a set of useful methods.
 * @param {string} novelTag A novel-specific name used when saving or restoring a game state.
 * @param {(function|function[])} factories A function or array of functions that return dictionaries of novel scenes.
 * @param {object} params Initial params.
 * @param {object} params.$ Initial game state. Should be JSON-serializable. Empty object by default.
 * @param {object} params.ext A helper object for passing custom functions or data to scenes.
 * @param {(object|object[])} params.callbacks Callbacks for standard events in form of object or array of objects.
 * @param {boolean} params.devMode Allows the engine to output logs. Essential during development.
 * @param {number} params.stepTime The time it takes to print each symbol in milliseconds. Instant if zero.
 * @param {string} params.cssPrefix Engine will use this when searching for CSS styles. Default is "novel".
 * @param {string} params.watchedAttr The engine will track elements with this attribute, listen to their events and apply CSS classes.
 * @param {string} params.imagesPath Path to the folder with portraits of the novel's characters.
 * @param {string} params.imagesType File extension of the novel's character portraits. Default is "png".
 * @param {(string|null)} params.firstScene Entry point of the novel, defaults to "start". Set to null to prevent the game from starting automatically.
 * @param {string} params.restoreFromSlot The game tries to load from the specified slot, "autosave" by default.
 * @param {boolean} params.startOver Should the game ignore the save data and start over?
 * @param {boolean} params.noReadWrite Do not read or write the game state. Default is false.
 * @param {boolean} params.noKeyboard Ignore keyboard controls. Default is false.
 * @param {boolean} params.useLocationHash If true, the game will store its state as the hash property of the window location object.
 * @param {(string|HTMLElement)} params.appendTo Where the novel element should be placed. Defaults to document.body.
 * @param {object} params.implementations An object with functions that will override certain engine methods. They run in the context of this object.
 * @param {object} params.delays Engine animation delays, for deep customization. See the engine file for a list of them.
 * @param {('left'|'right')} params.defaultAlign Starting alignment of each character. Default is "right".
 * @param {RegExp} params.multiLangSplitRegex Delimiter of multilingual strings. /\s+>>\s+/ by default.
 * @param {number} params.language Which part of the split multilingual string should be shown. Default: -1 (i.e. no translation).
 * @preserve
 */export default(U,C,{$:Ne={},ext:Pe={},callbacks:F=[],devMode:re=!0,stepTime:Ie=1e3/60,cssPrefix:r="novel",watchedAttr:O=void 0,imagesPath:ue="./images/",imagesType:je="png",firstScene:Fe="start",restoreFromSlot:We="autosave",startOver:qe=!1,noReadWrite:ie=!1,noKeyboard:fe=!1,useLocationHash:J=!1,appendTo:Y=document.body,implementations:Ge={},delays:Be={},defaultAlign:pe="right",multiLangSplitRegex:He=/\s+>>\s+/,language:oe=-1}={})=>{if(!C||Array.isArray(C)&&!C.length)throw new Error("You should provide at least one scene factory function.");const me="Sasuke",W=matchMedia("(pointer: coarse)").matches,Me=ue+(ue.endsWith("/")?"":"/"),De=je.toLowerCase();let z=!1,ge,V=!1;const Q="AbortSignal",X={},E={},S=()=>{if(V)throw Q},p={},R={},ye={},Z=[],q={};let G,g,m,be,_,ee,te,B=0,k=!1,se=!1,N=!1,H=!0,ae=!1,M=!1,D,L,A,u,le,y,K,$;const x={CHARACTER_SHOW:350,CHARACTER_HIDE:350,CHARACTER_MOOD_CHANGE:100,BEFORE_SELECT_ACTIVE:350,AFTER_OPTION_CLICK:250,BEFORE_FIRST_PRINT:500,BEFORE_SKIP_PRINTING:200,BEFORE_IDLE_PROCEED:500},d={onGameStart:null,onShow:null,onHide:null,onBeforeType:null,onStop:null,onSceneEnter:null,onSceneLeave:null,onWatcherCreate:null,onWatcherRemove:null,onEventEnter:null,onEventLeave:null,onShowOptions:null,onOptionClick:null,onStateChange:null,onGameEnd:null},b={getCharacterPortraitPath(t,e){return`${Me}${t}/${e}.${De}`},createKey(t,e){return`${t}(${e})`},writeState(t,e){if(J){let s={};try{s=JSON.parse(decodeURIComponent(window.location.hash).slice(1))}catch{}s[t]=e,window.history.pushState(void 0,void 0,"#"+JSON.stringify(s))}else localStorage.setItem(t,JSON.stringify(e))},readState(t){if(c("\u21BB",t),J){let e={};try{e=JSON.parse(decodeURIComponent(window.location.hash).slice(1))}catch{}return e[t]}else{let e;try{e=JSON.parse(localStorage.getItem(t))}catch{}return e}},clearSavedState(t){if(c("\u{1F5D1}\uFE0F",t),J){let e={};try{e=JSON.parse(decodeURIComponent(window.location.hash).slice(1))}catch{}delete e[t],window.history.replaceState(void 0,void 0,"#"+JSON.stringify(e))}else localStorage.removeItem(t)},onUserNavigates(){J&&window.history.go(0)}},ce=new Proxy(p,{set(t,e,s){return t.$[e]=s,d.onStateChange?.(e,s),!0},get(t,e){return t.$[e]}}),we=new Proxy(ye,{get(t,e){return Object.hasOwn(t,e)||(t[e]=new he(e)),t[e].proxy}}),P=(t=!1)=>{if(!V&&(N||t)&&_){N=!1;const e=_;_=null,e()}},ve=async t=>{if(V||!N||!ee)return;let e,s;if(typeof t=="number"){if(s=t,e=$.querySelectorAll("."+r+"-select-option")[t],!e)return}else{if(e=t.target,!e?.classList.contains(r+"-select-option"))return;s=[...$.querySelectorAll("."+r+"-select-option")].findIndex(o=>e===o)}N=!1,d.onOptionClick?.();const i=e.getAttribute("select-option-value")??s;for(const o of Object.keys(E))delete E[o];E[i]=!0,E.__value__=i,$.classList.add(r+"-select-hidden");const n=ee;ee=null,c("\u{1F449}",e.innerText),await v(x.AFTER_OPTION_CLICK),se=!1,n(i)},nt=t=>"\x1B[30m"+t+"\x1B[0m",rt=t=>"\x1B[31m"+t+"\x1B[0m",it=t=>"\x1B[32m"+t+"\x1B[0m",ot=t=>"\x1B[33m"+t+"\x1B[0m",at=t=>"\x1B[34m"+t+"\x1B[0m",lt=t=>"\x1B[35m"+t+"\x1B[0m",ct=t=>"\x1B[36m"+t+"\x1B[0m",ht=t=>"\x1B[37m"+t+"\x1B[0m",dt=t=>"\x1B[90m"+t+"\x1B[0m";class Ke{constructor(){Object.assign(x,Be),D=w(r+"-container",r+"-layer"),L=w(r+"-dialogs",r+"-layer"),A=w(r+"-choices",r+"-layer"),u=w(r+"-textbox",r+"-textbox-hidden"),le=w(r+"-message"),y=Ee(r+"-message-rendered"),K=Ee(r+"-message-placeholder"),$=w(r+"-select",r+"-select-hidden"),D.append(L,A),le.append(y,K),u.append(le),L.append(u),A.append($),L.addEventListener(W?"touchend":"click",()=>P()),$.addEventListener(W?"touchend":"click",s=>ve(s)),Array.isArray(F)||(F=[F]),O&&F.push(ze()),this.setCallbacks(F);for(const[s,i]of Object.entries(Ge))Object.hasOwn(b,s)?b[s]=i:console.error(`Unknown name for implementation given: "${s}".`);this.getScenes(),typeof Y=="string"&&(Y=document.querySelector(Y)),Y.append(D);const e=!qe&&this.loadState(We);e&&e.version===me?Object.assign(p,e):(c("\u{1F3AC}",U),Object.assign(p,this.createNewState()),Object.assign(p.$,Ne)),c("\u{1F4E6}",structuredClone(p)),I(()=>{z=!0,p.scene&&this.runScene(p.scene,p.args,!1),d.onGameStart?.(X),ge?.(X)})}setCallbacks(e){const s=Object.fromEntries(Object.keys(d).map(i=>[i,[]]));for(const i of e)for(const[n,o]of Object.entries(i)){if(!Object.hasOwn(s,n)){console.error("Unknown callback:",n);continue}s[n].push(o)}for(const[i,n]of Object.entries(s))n.length>0&&(d[i]=n.length===1?n[0]:function(...o){n.forEach(a=>a.apply(this,o))})}getScenes(){Array.isArray(C)||(C=[C]);for(const e of C)Object.entries(e({$:ce,_:Ye,select:xe,watch:Je,call:Qe,note:Xe,clear:Ze,sleep:v,save:this.saveState,log:c,ext:Pe})).forEach(([s,i])=>{Object.hasOwn(R,s)?console.error("Scene redeclaration:",s):R[s]=new Ue(s,i)})}saveState(e="autosave"){if(S(),ie)return;const s=b.createKey?.(U,e);return b.writeState?.(s,structuredClone(p))}loadState(e){if(S(),ie)return;const s=b.createKey?.(U,e);return b.readState?.(s)}clearSaveSlot(e){if(S(),ie)return;const s=b.createKey?.(U,e);return b.clearSavedState?.(s)}createNewState(){return{scene:Fe,args:[],$:{},characters:{},version:me}}async runScene(e,s=[],i=!0){if(S(),s.length?c("\u26F0\uFE0F",e,s):c("\u26F0\uFE0F",e),e?.[0]==="~"?e=e.slice(1):m?.hide(),g&&g.end(),!Object.hasOwn(R,e)){console.error("Trying to run unknown scene:",e);return}g=R[e],p.scene=e,p.args=structuredClone(s),i&&this.saveState("autosave");for(const o of Object.keys(E))delete E[o];d.onSceneEnter?.(e,!0);let n;try{n=structuredClone(await g.run(...structuredClone(s)))}catch(o){if(o===Q){c("\u270B","The game was manually interrupted."),c("\u{1FA82}","Emergency exiting.");return}else throw o}d.onSceneLeave?.(e,!0),typeof n=="string"?setTimeout(()=>this.runScene(n)):Array.isArray(n)&&typeof n[0]=="string"?setTimeout(()=>this.runScene(n[0],n.slice(1))):n!==void 0&&(c("\u{1F3C1}","Game ended."),d.onGameEnd?.(n))}async notify(e,...s){if(S(),c("\u26A1",e),!g){console.error(`Event "${e}" occured while no scene is active`);return}if(!H){console.error(`Event "${e}" occured while the script flow was not ended.`);return}const i=g.watchers.find(n=>n.event===e);if(!i){c("\u{1F965}","No such watcher.");return}if(!i.cb){c("\u{1F34B}","Callback not set.");return}if(i){H=!1,d.onEventEnter?.(e,...s);let n;try{n=structuredClone(await i.cb(...s))}catch(o){if(o===Q){c("\u270B","The game was manually interrupted."),c("\u{1FA82}","Emergency exiting.");return}else throw o}d.onEventLeave?.(e,n),typeof n=="string"||Array.isArray(n)&&typeof n[0]=="string"?be(n):(n===!1&&g.removeWatcher(e),m?.hide(),A.style.pointerEvents="none",L.style.pointerEvents="none",H=!0,c("\u26F0\uFE0F",g.id,"\u21A9"))}}}class Ue{watchers=[];constructor(e,s){this.id=e,this.cb=s}async run(...e){let s=await this.cb(we,...e);return s===void 0&&(H=!0,m?.hide(),A.style.pointerEvents="none",L.style.pointerEvents="none",D.style.pointerEvents="none",this.watchers.length?s=await new Promise(i=>{be=i}):c("\u{1F6A7}","The game has stalled.")),s}removeWatcher(e){const s=this.watchers.findIndex(i=>i.event===e);s!==-1&&(this.watchers.splice(s,1),d.onWatcherRemove?.(e),c("\u{1F9F9}",e))}end(){this.watchers.forEach(({event:e})=>{d.onWatcherRemove?.(e)}),this.watchers=[]}}function Je(t,e){if(S(),g.watchers.some(i=>i.event===t)){console.error(`Multiple watchers of the same event (${t}) not allowed at scene (${g.id})`);return}c("\u{1F4CC}",t),g.watchers.push({event:t,cb:e}),d.onWatcherCreate?.(t);const s=g.id;return{then:()=>{console.error(`There is no point in "await" before "watch" (scene: "${s}", event: "${t}").`)}}}class he{constructor(e){c("\u{1F98A}",e),this.id=e,this.label="",this.align=pe,this.flipped=!1,this.visible=!1,this.timeout,this.mood="normal",this.queue=[];let s="normal";const i=(...n)=>{if(re){for(const{id:o,queue:a}of Object.values(ye))if(a.length){console.error(`Unexpected state. Check the "await" before these words of ${o}:`,[...a]);return}}return this.proxy__(...n)};if(Object.assign(i,{$toLeft:()=>(this.setAlign("left"),p.characters[e].align="left",this.proxy_),$toRight:()=>(this.setAlign("right"),p.characters[e].align="right",this.proxy_),$setLabel:n=>(this.setLabel(n),p.characters[e].label=n,this.proxy_),$flipImage:()=>(this.setFlip(!this.flipped),p.characters[e].flipped=this.flipped,this.proxy_),then:()=>{console.error(`Seemingly useless "await" before ${this.id}'s handle. This error may be caused by:
1. Erroneous usage of "await" with syncronous methods like "$toLeft", "$toRight", "$setLabel".
2. Using quotes or double quotes instead of backticks in parenthesis-less notation.
3. Using a comma or semicolon before the first argument in parenthesis-less notation.`)}}),this.proxy=new Proxy(i,{get:(n,o)=>Object.hasOwn(n,o)?n[o]:(s=o,this.proxy__)}),this.proxy_=new Proxy(i,{apply:()=>{console.error("Direct function call in a method chain. Chaining of methods and function calls is prohibited.")}}),this.proxy__=new Proxy(i,{get:(n,o)=>{if(o==="then")return async(a,h)=>{const l=this.queue;this.queue=[],await this.say(s,...l).catch(h),s="normal",a()};console.error(`Once the call chain has started, property getting is not allowed. Requested property: "${o}".`)},apply:(n,o,a)=>(Array.isArray(a[0])&&Array.isArray(a[0].raw)&&(a=[_e(...a)]),this.queue.push(...a),this.proxy__)}),this.$el=w(r+"-character",r+"-character-id-"+e,r+"-character-align-"+this.align,r+"-character-inactive"),this.$portraits=w(r+"-character-portraits"),this.$label=w(r+"-label",r+"-label-id-"+e,r+"-label-hidden"),this.$el.append(this.$portraits,this.$label),Object.hasOwn(p.characters,e)){const n=p.characters[e];this.setLabel(n.label),this.setAlign(n.align),this.setFlip(n.flipped),c("\u21BB",n)}else p.characters[e]={}}setLabel(e=""){this.$label.innerText=e,this.label=e,e?this.visible&&this.$label.classList.remove(r+"-label-hidden"):this.$label.classList.add(r+"-label-hidden")}setAlign(e=pe){e!==this.align&&(this.$el.classList.remove(r+"-character-align-"+this.align),this.$el.classList.add(r+"-character-align-"+e),this.align=e,this.visible&&this.updateTextboxAlign())}setFlip(e=!1){this.flipped=e,e?this.$el.classList.add(r+"-character-flipped"):this.$el.classList.remove(r+"-character-flipped")}setMood(e){return e!==this.mood?(this.$el.classList.remove(r+"-character-mood-"+this.mood),this.$el.classList.add(r+"-character-mood-"+e),this.mood=e,!0):!1}async show(e=this.mood){const s=this.setMood(e),i=!!m&&m===this,n=!!m&&m.align===this.align;let o=this.$portraits.querySelector("."+r+"-portrait-mood-"+e);o?o.classList.contains(r+"-portrait-hidden")&&this.$portraits.append(o):(o=w(r+"-portrait",r+"-portrait-mood-"+e,r+"-portrait-hidden"),this.$portraits.append(o),await new Promise(a=>{let h=b.getCharacterPortraitPath(this.id,e);re&&(h+="?"+Math.random());const l=new Image;l.src=h,l.onload=()=>{o.style.backgroundImage=`url('${h}')`,a()},l.onerror=()=>{a()}})),i||(n?await m?.hide():m?.hide()),o.classList.contains(r+"-portrait-hidden")&&I(()=>{o.classList.remove(r+"-portrait-hidden")}),this.visible?await I(async()=>{await v(s?x.CHARACTER_MOOD_CHANGE:0);for(let a=0;a<this.$portraits.children.length-1;a++)this.$portraits.children[a].classList.add(r+"-portrait-hidden");this.updateTextboxAlign()}):(this.visible=!0,m=this,y.replaceChildren(),K.innerText="",L.append(this.$el),clearTimeout(this.timeout),d.onShow?.(this.id),await I(()=>{this.$el.classList.remove(r+"-character-inactive"),u.classList.remove(r+"-textbox-hidden");for(let a=u.classList.length-1;a>=0;a--){const h=u.classList[a];h.startsWith(r+"-textbox-of-")&&u.classList.remove(h)}u.classList.add(r+"-textbox-of-"+this.id),this.updateTextboxAlign()}),this.label?this.$label.classList.remove(r+"-label-hidden"):this.$label.classList.add(r+"-label-hidden"),await v(x.CHARACTER_SHOW))}async hide(){if(!this)await I(()=>{k||u.classList.add(r+"-textbox-hidden")});else if(this.visible){this.visible=!1,m=void 0,this.$el.classList.remove(r+"-character-mood-"+this.mood),this.$el.classList.add(r+"-character-inactive"),this.$label.classList.add(r+"-label-hidden");for(const e of this.$portraits.children)e.classList.add(r+"-portrait-hidden");await I(()=>{k||u.classList.add(r+"-textbox-hidden")}),d.onHide?.(this.id),this.timeout=setTimeout(()=>this.$el.remove(),5e3),await v(x.CHARACTER_HIDE)}}updateTextboxAlign(){this.align==="left"?(u.classList.remove(r+"-textbox-right"),u.classList.add(r+"-textbox-left")):(u.classList.remove(r+"-textbox-left"),u.classList.add(r+"-textbox-right"))}async say(e,...s){if(S(),k||se){console.error("Message from "+(this?.id??"[note]")+' was ignored because the previous task was not finished. Check if you placed "await"s correctly.'),console.error("Message:",s);return}k=!0,L.style.pointerEvents="all",A.style.pointerEvents="none";const i=[];for(const n of s)Array.isArray(n)?i.push(...n):i.push(n);if(this)u.classList.remove(r+"-textbox-note"),await this.show(e);else{const n=u.classList.contains(r+"-textbox-hidden"),o=n||!!m;m?.hide(),y.replaceChildren(),K.innerText="",u.classList.remove(r+"-textbox-left"),u.classList.remove(r+"-textbox-right"),u.classList.add(r+"-textbox-note"),n&&u.classList.remove(r+"-textbox-hidden"),o&&await v(x.BEFORE_FIRST_PRINT)}for(let n=0;n<i.length;n++){if(typeof i[n]!="string")continue;let o=!1,a=0,h=Ie,l=[];typeof i[n+1]=="number"&&(o=!0,a=i[n+1]);let[f,j]=$e(Se(i[n]));if(f[0]==="["){const T=f.indexOf("]");if(T!==-1){const ne=f.indexOf("::");(ne===-1||ne>T)&&(l=f.slice(1,T).split(""),j=j.slice(T+1),f=f.slice(T+1))}}l.includes("!")&&(h=0),l.includes("~")&&(h=h*2),await et(...Ce(f,j),h),Z.push({id:this?.id??"[note]",label:this?.label??"[note]",text:y.innerText}),Z.length>100&&Z.shift(),o?y.classList.add(r+"-message-rendered-writing"):y.classList.add(r+"-message-rendered-stopped");let Re;const st=new Promise((T,ne)=>{Re=T,te=ne}),ke=()=>(N=!0,d.onStop?.(),st);_=()=>{y.classList.remove(r+"-message-rendered-writing"),y.classList.remove(r+"-message-rendered-stopped"),Re()},M&&await v(x.BEFORE_SKIP_PRINTING),M?P(!0):o?(await v(a),P(!0)):q[" "]?(await v(x.BEFORE_IDLE_PROCEED),q[" "]?P(!0):await ke()):await ke()}k=!1}}const xe=async(...t)=>{if(S(),c("\u{1F4CB}",t),k||se){console.error('Cannot show selectable options because the previous task was not finished. Check if you placed "await"s correctly.'),console.error("Options:",t);return}if(t=t.filter(e=>typeof e=="string"||e instanceof Object),!!t.length)return se=!0,N=!0,A.style.pointerEvents="all",$.replaceChildren(...t.map(e=>{const s=w(r+"-select-option");if(typeof e!="string"){const a=Object.entries(e)[0];s.setAttribute("select-option-value",a[0]),e=a[1]}const[i,n]=Ce(...$e(Se(e))),o=Le(i);for(let a=0;a<o.length;a++)o[a].style.pointerEvents="none",d.onBeforeType?.(i[a],o[a],n[a],0,!0);return s.replaceChildren(...o),s})),$.classList.remove(r+"-select-hidden"),d.onShowOptions?.(),await v(x.BEFORE_SELECT_ACTIVE),new Promise((e,s)=>{te=s,ee=e})},Ye=new Proxy(xe,{set(){console.error("This object is readonly.")},get(t,e){if(Object.hasOwn(E,e))return E[e]}}),w=(...t)=>{const e=document.createElement("div");return e.classList.add(...t),e},Ee=(...t)=>{const e=document.createElement("span");return e.classList.add(...t),e},I=t=>new Promise(e=>{requestAnimationFrame(()=>{requestAnimationFrame(async()=>{await t(),e()})})});function de(){G.notify(this.getAttribute(O))}const ze=()=>{const t=[];return{onWatcherCreate(e){document.querySelectorAll(`[${O}="${e}"]`).forEach(s=>{s.classList.add(r+"-watched"),s.addEventListener(W?"touchend":"click",de),t.push(s)})},onWatcherRemove(e){for(let s=t.length-1;s>=0;s--){const i=t[s];i.getAttribute(O)===e&&(i.classList.remove(r+"-watched"),i.removeEventListener(W?"touchend":"click",de),t.splice(s,1))}},onEventEnter(e){t.forEach(s=>{s.getAttribute(O)===e?s.classList.add(r+"-watched-clicked"):s.classList.add(r+"-watched-clicked-other")})},onEventLeave(){t.forEach(e=>{e.classList.remove(r+"-watched-clicked"),e.classList.remove(r+"-watched-clicked-other")})}}},Ve=()=>{document.removeEventListener("keydown",Oe),document.removeEventListener("keyup",Ae),window.removeEventListener("popstate",Te),O&&document.querySelectorAll(`[${O}]`).forEach(t=>{t.removeEventListener(W?"touchend":"click",de),t.classList.remove(r+"-watched"),t.classList.remove(r+"-watched-clicked"),t.classList.remove(r+"-watched-clicked-other")})},Qe=(t,...e)=>{if(!Object.hasOwn(R,t)){console.error("Trying to call unknown scene:",t);return}if(B>99){console.error(`Scene "${t}" cannot be called: stack size limit reached (${B}).`);return}return B+=1,e.length?c("\u{1F4AC}",t,e):c("\u{1F4AC}",t),(async()=>{d.onSceneEnter?.(t,!1);const s=await R[t].cb(we,...e);return d.onSceneLeave?.(t,!1),B-=1,B||c("\u26F0\uFE0F",g?.id,"\u21A9"),s})()},Xe=(...t)=>he.prototype.say.call(null,null,...t),Ze=()=>m?m.hide():he.prototype.hide.call(null),v=t=>new Promise((e,s)=>{te=s,setTimeout(e,t)}),Se=t=>{if(oe!==-1&&typeof t=="string"){const e=t.split(He);return oe<e.length?e[oe]:e[0]}return t},_e=(t,...e)=>{let s="";for(let i=0;i<t.length;i++)s+=t[i],i<t.length-1&&(s+=`${e[i]}`);return s},et=(t,e,s,i)=>{const n=Le(t);return y.replaceChildren(),K.append(...n),new Promise(o=>{const a=h=>{if(M||i===0){for(let l=0;l<n.length;l++)d.onBeforeType?.(t[l],n[l],e[l],0,!1);y.append(...n),o()}else if(h<s.length){const l=i/(ae?2:1);setTimeout(()=>{let f;if(h<n.length){const j=n[h];f=d.onBeforeType?.(t[h],j,e[h],l,!1),y.append(j)}f&&typeof f=="number"?setTimeout(()=>a(h+1),f):a(h+1)},l+s[h])}else o()};a(0)})},tt=t=>{const e=document.createElement("span");return e.innerText=t,e},Le=t=>{const e=[];for(const s of t)e.push(tt(s));return e},$e=t=>{const e=t.split(""),s=new Array(t.length).fill(0);let i=0;for(const{"0":n,"1":o,index:a}of t.matchAll(/\[(\d+)\]/g))e.splice(a-i,n.length),s.splice(a-i,n.length),s[a-i]=+o,i+=n.length;return[e.join(""),s]},Ce=(t,e=[])=>{const s=t.split(""),i=new Array(t.length).fill(void 0);let n=0;for(const o of t.matchAll(/\[(.*?)::(.*?)\]/g)){const{"1":a,"2":h,index:l}=o;e.splice(l-n+1,a.length+2),s.splice(l-n+1,a.length+2),i.splice(l-n+1,a.length+2);for(let f=l-n+1;f<l-n+1+h.length;f++)i[f]=a;n+=a.length+2}n=0;for(const o of s.join("").matchAll(/([\p{L}\d_]*)::([\p{L}\d_\-]*)/gu)){const{"1":a,"2":h,index:l}=o;e.splice(l-n+1,a.length+2),s.splice(l-n,a.length+2),i.splice(l-n,a.length+2);for(let f=l-n;f<l-n+h.length;f++)i[f]=a;n+=a.length+2}for(let o=s.length-1;o>=0;o--){const a=s[o];(a==="["||a==="]")&&(s.splice(o,1),i.splice(o,1),e.splice(a==="["?o+1:o,1))}return[s.join(""),i,e]},c=(...t)=>{re&&console.log(...t.map(e=>e===ce?p.$:e))},Oe=({key:t})=>{if(!fe&&!q[t])switch(q[t]=!0,t){case" ":ae=!0,P();break;case"Control":P(),M=!0;break;case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":ve(t-1);break}},Ae=({key:t})=>{if(!fe)switch(delete q[t],t){case" ":ae=!1;break;case"Control":M=!1;break}},Te=t=>{b.onUserNavigates?.()};return document.addEventListener("keydown",Oe),document.addEventListener("keyup",Ae),window.addEventListener("popstate",Te),G=new Ke,Object.assign(X,{event:(t,...e)=>{if(!z){console.error('Game is not ready. Use "await createNovel(...).promise" for proper timing.');return}G.notify(t,...e)},runScene:(t,...e)=>{if(!z){console.error('Game is not ready. Use "await createNovel(...).promise" for proper timing.');return}if(!H){console.error(`Manual scene run failed: script flow not ended. (Scene: "${t}")`);return}G.runScene(t,e)},$:ce,getHistory:()=>Z,clearSaveSlot:(t="autosave")=>G.clearSaveSlot(t),remove:()=>{if(!z){console.error('Game is not ready. Use "await createNovel(...).promise" for proper timing.');return}V=!0,Ve(),D.remove();for(const t of Object.keys(d))d[t]=null;for(const t of Object.keys(b))b[t]=null;te?.(Q)},sleep:v,log:c,promise:new Promise(t=>{ge=t})}),X};
